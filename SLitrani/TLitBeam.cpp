// @(#)root/html:$Id: TLitBeam.cpp 2008-06-11
// Author: F.X. Gentit <http://gentit.home.cern.ch/gentit/>

/*************************************************************************
* Copyright (C) Those valid for CNRS software.                          *
*************************************************************************/
#include "TROOT.h"
#include "TGeoTube.h"
#include "TGeoEltu.h"
#include "TGeoManager.h"
#include "TGeoPhysicalNode.h"
#include "TSplineFit.h"
#include "TCleanOut.h"
#include "TLitPhys.h"
#include "TLitMedium.h"
#include "TLitVolume.h"
#include "TLitPhoton.h"
#include "TLitParticle.h"
#include "TLitDetector.h"
#include "TLitResults.h"
#include "TLitMarrow.h"
#include "TLit.h"
#include "TLitBeam.h"

ClassImp(TLitBeam)
//______________________________________________________________________________
//
//  TLitBeam defines a beam of particles, for instance muons.
//
//    (A) Type of particle and momentum distribution
//
//  The type of particle must have been chosen before, by intanciating class
// TLitParticle. This defines also the distribution in momentum of the generated
// particles.
//
//    (B) Characteristics of emission
//
//  The characteristics of emission for the particles are defined exactly in the same
// way as they were defined for the photons in TLitVolume::SetEmission(). There are 3
// possibilities for the point of emission of particles by the TGeoVolume
// fStartGeoVol acting as beam cradle:
//  (1) - anywhere in fStartGeoVol: particles are emitted from any point inside
//        fStartGeoVol with an equal probability.
//  (2) - fixed point in TGeoVolume: all particles are emitted from a fixed point
//        inside fStartGeoVol
//  (3) - surface emission: first, a point is generated inside fStartGeoVol, anywhere
//        with an equal probability. Then the point is translated inside fStartGeoVol,
//        along a specified direction, until the edge of fStartGeoVol. It is the way
//        SLitrani generates surface emission, without having [as the old Litrani] any
//        handling of faces. This method has the advantage of working, whatever the
//        kind of TGeoVolume.
//  For more details about characteristics of emission, look at method TLitBeam::
// SetEmission().
//
//    (C) Energy loss
//
//  The dE/dx generated by the particle during crossing of a TLitMedium is specified
// by a TSplineFit. It has been specified for each medium intended to generate light
// when crossed by particles by a call to method TLitMedium::dEdx(). Look at this
// method. Notice the following important restrictions in the handling of particle
// crossing, recalling that SLitrani is not GEANT4!
//  (1) - Light emission only occurs inside TGeoVolume containing a TLitMedium for
//        which TLitMedium::dEdx() has been called. No ligth emission inside a
//        TGeoMedium.
//  (2) - The dEdx is calculated only to determine the number of photons produced.
//        The particle itself does not loose energy. It has the same energy during
//        the crossing of the whole setup.
//  (3) - The trajectory of the particle is a straight line inside the setup. No
//        simulation of delta rays or multiple scattering.
//  So the simulation of the crossing of a particle by SLitrani is better suited to
// particles of high energy. Look at class TLitGamma for the simulation of gammas
// of small energy.
//
//    (D) Generation
//
//  After having called the constructor of TLitBeam, after having called TLitBeam::
// SetEmission(), the generation of the particles is done by a call to method
// TLitBeam::Gen().
//
TLitBeam::TLitBeam(const char *name,const char *title,const char *path,TLitParticle *part,
  Bool_t moving,Bool_t checkmove):TNamed(name,title) {
  //  Defines a beam of particles of type "part", starting from a TGeoVolume pointed by
  // node "path". For this constructor, TLitParticle "part" MUST have been booked
  // before calling TLitBeam::TLitBeam. If you do not do so, you will have as default
  // mu- of fixed momentum of 100 Gev/c. Notice that deleting TLitBeam will not
  // delete "part". You have to do it yourself if you want it. TLitBeam is not
  // owner of "part"
  //
  //  Arguments :
  //
  //  name      : name of this source of particles
  //  title     : title of this source of particles
  //  path      : path name of the TGeoVolume inside which particle is generated
  //              for instance "/TOP_1/REV_1"
  //  part      : type of particles generated. If you give 0, mu- of 100Gev/c
  //              will be defined
  //  moving    : if moving is true [default false], the TGeoVolume acting as
  //              beam cradle and pointed to by path will be moved from run
  //              to run, by a call to method MoveCradle(). Notice that displacing
  //              a TGeoVolume AFTER the geometry has been closed by a call to
  //              gGeoManager->CloseGeometry() cannot be done simply by calling
  //              TGeoVolume::RemoveNode() and TGeoVolume::AddNode(). Read
  //              § "Representing Misalignments of the Ideal Geometry", p340 of the
  //              ROOT user manual to understand how it is done, using class
  //              TGeoPhysicalNode.
  //  checkmove : if true [default false], ask TGeo to check that no extrusion
  //              have occured during the move
  //
  //  Calling this constructor is not enough: you have to define the emission
  // characteristics of the beam by a call to TLitBeam::SetEmission().
  // If you forget to call TLitBeam::SetEmission(), it will be called with
  // all default values, which will probably not suit your needs.
  //
  const char *met = "TLitBeam";
  TString nameGeoV = "";
  Init();
  if (!part) fParticle = new TLitParticle(13);
  else       fParticle = part;
  fSourcePath  = path;
  NameFromPath(nameGeoV);
  fStartGeoVol = gGeoManager->FindVolumeFast(nameGeoV.Data());
  if (!fStartGeoVol) gCleanOut->MM(fatal,met,"TGeoVolume not found",ClassName());
  fStartLitVol = (TLitVolume*)fStartGeoVol->GetField();
  fMoving    = moving;
  fCheckMove = checkmove;
  if (fMoving) {
    fGeoPhysNode = new TGeoPhysicalNode(fSourcePath.Data());
    if (!fGeoPhysNode) gCleanOut->MM(fatal,met,"TGeoPhysicalNode not created",ClassName());
    if (nameGeoV.CompareTo(fStartGeoVol->GetName()))
      gCleanOut->MM(fatal,met,"Bad name for TGeoPhysicalNode",ClassName());
  }
  if (!TLitResults::fgResults) TLitResults::fgResults = new TObjArray();
  if (!gLitGs) gLitGs = new TLitResults("GlobStat","Global statistics of all runs",0);
  SetEmission();
}
TLitBeam::~TLitBeam() {
  //  TLitBeam is not owner of fParticle
  if (fPhot) {
    delete fPhot;
    fPhot = 0;
  }
}
Bool_t TLitBeam::EmissionToWCS() {
  //  Given a fSourcePath like "/T_1/A_2/B_2", pointing to a particular instance [node] of
  // a TGeoVolume, calculates:
  //
  //  (1) fSourcePoint => fWCSSourcePoint  position of emission point in WCS
  //  (2) fSourceDir   => fWCSSourceDir    direction of emission in WCS
  //  (4) fDirFace     => fWCSDirFace      direction to take to reach face, in WCS
  //
  //  This method also transfers the emission point fWCSSourcePoint towards the
  // face of the TGeoVolume, along direction fWCSDirFace in case fFromFace is
  // true.
  //  fSourcePath must have been set before calling this method
  //  To be called only AFTER closing of the geometry
  //
  const char *met = "EmissionToWCS";
  const char lim = '/';
  Int_t kk;
  Short_t depth; //depth of fSourcePath
  Short_t k;     //index inside fSourcePath
  Short_t nn;    //next  '/' to be reached
  Short_t n;     //counter of '/' encountered
  Ssiz_t  N;     //Length of string fSourcePath
  Short_t j;
  Bool_t found1 = kFALSE;
  Bool_t found;
  Double_t x,y;
  Double_t local1[3],master1[3];       // for fSourcePoint
  Double_t localdir[3],masterdir[3];   // for fSourceDir
  Double_t local3dir[3],master3dir[3]; // for fDirFace
  TGeoVolume *vol;
  TGeoNode *node;
  TGeoNode *daughter = 0;
  TGeoNode *foundnode[10];
  TObjArray *nodes;
  TString snode,sdaughter;
  depth = TLit::Get()->CheckPath(fSourcePath);
  switch (depth) {
    case 0:
      gCleanOut->MM(fatal,met,"Bad path of Tgeo",ClassName());
      break;
    case 1:
      fWCSSourcePoint = fSourcePoint;
      fWCSSourceDir   = fSourceDir;
      if (fFromFace) fWCSDirFace = fDirFace;
      found1    = kTRUE;
      break;
    default:
      N  = fSourcePath.Length();
      if (fSourcePath(N-1)==lim) fSourcePath.Resize(--N);
      for (k=0;k<3;k++) {
        local1[k]   = fSourcePoint[k];
        localdir[k] = fSourceDir[k];
        if (fFromFace)     local3dir[k] = fDirFace[k];
      }
      k  = 0;
      n  = 0;
      nn = 2;
      while ((k<N) && (n<nn)) {
        if (fSourcePath(k) == lim) n++;
        k++;
      }
      nn++; 
      vol = gGeoManager->GetTopVolume();
      found = kTRUE;
      while ((found) && (k<N)) {
        snode = "";
        while ((k<N) && (n<nn)) {
          if (fSourcePath(k) == lim) n++;
          else snode.Append(fSourcePath(k)); 
          k++;
        }
        nodes = vol->GetNodes();
        TIter next(nodes);
        found = kFALSE;
        while ((!found) && (node = (TGeoNode*)next())) {
          if (!snode.CompareTo(node->GetName())) {
            daughter = node;
            foundnode[nn-3] = node;
            found = kTRUE;
          }
        }
        if (found) vol = daughter->GetVolume();
        nn++;
      }// end while ((found) && (k<N))
      found1 = found;
      nn -= 3;
      if (found1) {
        for (k=0;k<nn;k++) {
          node = foundnode[nn-k-1];
          node->LocalToMaster(local1,master1);
          node->LocalToMasterVect(localdir,masterdir);
          if (fFromFace)     node->LocalToMasterVect(local3dir,master3dir);
          for (j=0;j<3;j++) {
            local1[j] = master1[j];
            localdir[j] = masterdir[j];
            if (fFromFace)     local3dir[j] = master3dir[j];
          }
        }
        for (j=0;j<3;j++) {
          fWCSSourcePoint[j] = master1[j];
          fWCSSourceDir[j]   = masterdir[j];
          if (fFromFace)     fWCSDirFace[j] = master3dir[j];
        }
      }
      break;
  }//end switch (depth)
  //  Generation of a complete coordinate system in WCS, having fWCSSourceDir as
  // z axis.
  fWCSSourceDir = fWCSSourceDir.Unit();
  fAxisb1.SetXYZ(1.0,0.0,0.0);
  fAxisb2.SetXYZ(0.0,1.0,0.0);
  x = TMath::Abs(fAxisb1*fWCSSourceDir);
  y = TMath::Abs(fAxisb2*fWCSSourceDir);
  if (x<=y) {
    fAxisb2 = fWCSSourceDir.Cross(fAxisb1);
    fAxisb2 = fAxisb2.Unit();
    fAxisb1 = fAxisb2.Cross(fWCSSourceDir);
    fAxisb1 = fAxisb1.Unit();
  }
  else {
    fAxisb1 = fWCSSourceDir.Cross(fAxisb2);
    fAxisb1 = fAxisb1.Unit();
    fAxisb2 = fWCSSourceDir.Cross(fAxisb1);
    fAxisb2 = fAxisb2.Unit();
  }
  if (TLit::Get()->GetTestCalc()) {
    const Double_t eps = 1.0e-12;
    x = TMath::Abs(fAxisb1*fAxisb2);
    if (x>eps) gCleanOut->MM(error,met,"fAxisb1 not orthogonal to fAxisb2",ClassName());
    x = TMath::Abs(fAxisb1*fWCSSourceDir);
    if (x>eps) gCleanOut->MM(error,met,"fAxisb1 not orthogonal to fWCSSourceDir",ClassName());
    x = TMath::Abs(fAxisb2*fWCSSourceDir);
    if (x>eps) gCleanOut->MM(error,met,"fAxisb2 not orthogonal to fWCSSourceDir",ClassName());
    x = TMath::Abs(1.0-fAxisb1*(fAxisb2.Cross(fWCSSourceDir)));
    if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
  }
  const char *path;
  if (fFromFace) {
    const Double_t *point;
    fWCSDirFace = fWCSDirFace.Unit();
    fNode = gGeoManager->InitTrack(fWCSSourcePoint[0],fWCSSourcePoint[1],fWCSSourcePoint[2],
      fWCSDirFace[0],fWCSDirFace[1],fWCSDirFace[2]);
    path = gGeoManager->GetPath();
    // Go just after the exit face
    fNode = gGeoManager->FindNextBoundaryAndStep(TLitPhys::Get()->BiggestStep());
    point = gGeoManager->GetCurrentPoint();
    fWCSSourcePoint.SetXYZ(point[0],point[1],point[2]);
    gGeoManager->SetCurrentDirection(fWCSSourceDir[0],fWCSSourceDir[1],fWCSSourceDir[2]);
  }
  else {
    fNode = gGeoManager->InitTrack(fWCSSourcePoint[0],fWCSSourcePoint[1],fWCSSourcePoint[2],
      fWCSSourceDir[0],fWCSSourceDir[1],fWCSSourceDir[2]);
    path = gGeoManager->GetPath();
  }
  kk = fSourcePath.CompareTo(path);
  if (kk) {
    found1 = kFALSE;
    gCleanOut->MM(error,met,"User path different from found path",ClassName());
    gCleanOut->MMT(error,met,fSourcePath.Data(),"given by","user",ClassName());
    gCleanOut->MMT(fatal,met,path,"found by","TGeo",ClassName());
  }
  if (!found1) gCleanOut->MM(fatal,met,"EmissionToWCS failed",ClassName());
  return found1;
}
void TLitBeam::EmitLight(Double_t stp) {
  //  Emits light in step stp. First emit light due to dE/dx
  // then emit light due to Cerenkov radiation
  const char *met = "EmitLight";
  Int_t kphot,bin;
  Double_t x;
  Int_t ntimes;
  Int_t kfluo;
  Axis_t afluo;
  TVector3 K;         //k vector of generated photon
  TVector3 E;         //direction of the E field of the photon
  Double_t tstart;    //distance in [cm] between start of step and generation of photon
  Bool_t   stepok;    //fStep is correctly adjusted
  Int_t    nphotdEdx; //number of photons due to dEdx (integer !)
  Int_t    nphotCer;  //number of photons due to Cerenkov radiation
  Double_t DeltaE;    //energy deposited in step [Mev]
  Double_t PhotMev;   //number of photons generated per Mev of deposited energy
  Double_t PhotdEdx;  //number of photons due to dEdx (real !)
  Double_t reliquat;  //left-over energy due to discretization of the number of photons
  stepok = kFALSE;
  ntimes = 0;
  DeltaE    = fLitMedium->GetdEdx(fParticle->Energy());
  PhotMev   = fLitMedium->GetPhotMev();
  PhotdEdx  = stp*DeltaE*PhotMev;
  nphotdEdx = Int_t(PhotdEdx);
  reliquat = PhotdEdx - nphotdEdx;
  x = gRandom3->Rndm();
  if (reliquat>=x) nphotdEdx += 1;
  //
  //loop on generation of photons due to dEdx
  //
  gCleanOut->MMI(info,met,"Nb. of dEdx photons in step","NdEdx",nphotdEdx,ClassName());
  for (kphot=1;kphot<=nphotdEdx;kphot++) {
    gLitGs->fNpGener++;
    if (gLitCs) gLitCs->fNpGener++;
    //determines where, along the step, the photon is emitted
    tstart = stp*gRandom3->Rndm();
    fX0    = fX + tstart*fDir;
    //determines wavelength and time of emission of photon
    fLitMedium->WaveAndLife(fWvlgth,fT0,kfluo);
    fT0 += fTime + tstart/fParticle->GetSpeed();
    //update all values depending upon wavelength
    TLitMedium::NewWavelengthAll(fWvlgth);
    TLitVolume::NewWavelengthAll(fWvlgth);
    bin = gLitGs->fHTimeAll->Fill(fT0);
    bin = gLitGs->fHWvlgthAll->Fill(fWvlgth);
    if (gLitCs) {
      bin = gLitCs->fHTimeAll->Fill(fT0);
      bin = gLitCs->fHWvlgthAll->Fill(fWvlgth);
    }
    if (gLitGs->HasFluo()) {
      afluo = kfluo;
      bin = gLitGs->fHTimeEach->Fill(fT0,afluo);
      bin = gLitGs->fHWvlgthEach->Fill(fWvlgth,afluo);
    }  //if (gLitGs->HasFluo())
    if ((gLitCs) && (gLitCs->HasFluo())) {
      afluo = kfluo;
      bin = gLitCs->fHTimeEach->Fill(fT0,afluo);
      bin = gLitCs->fHWvlgthEach->Fill(fWvlgth,afluo);
    }  //if (gLitCs)
    //generates the photon
    GenK(K);
    GenE(K,E);
    fPhot = new TLitPhoton(fRun,kphot,fX0,fGeoVolume,fPath.Data(),fWvlgth,fT0,K,E,0);
    //follow the photon from its birth to its death
    fPhot->Move();
    if (gLitGs->fNpAbnorm>TLitPhys::Get()->Anomalies()) {
      gCleanOut->MM(fatal,met,"Too many anomalies",ClassName());
    }
    delete fPhot;
    fPhot = 0;
  }// end for (kphot=1;kphot<=nphotdEdx;kphot++)
  //
  //generation of photons due to Cerenkov radiation
  //
  if (fParticle->EmitCerenkov()) {
    fParticle->Cerenkov(fnCerenkov,stp);
    nphotCer = fParticle->NbCerPhot();
    gCleanOut->MMI(info,met,"Nb. of Cerenkov photons in step","nphotCer",nphotCer,ClassName());
    //loop on generation of photons due to Cerenkov radiation
    for (kphot=1;kphot<=nphotCer;kphot++) {
//      gCleanOut->RunEv(fRun,kphot);
      gLitGs->fNpGener++;
      if (gLitCs) gLitCs->fNpGener++;
      //determines where, along the step, the photon is emitted
      tstart = stp*gRandom3->Rndm();
      fX0    = fX + tstart*fDir;
      //determines wavelength and time of emission of photon
      WandLCerenkov(fWvlgth,fT0);
      fT0 += fTime + tstart/fParticle->GetSpeed();
      //update all values depending upon wavelength
      TLitMedium::NewWavelengthAll(fWvlgth);
      TLitVolume::NewWavelengthAll(fWvlgth);
      bin = gLitGs->fHTimeCer->Fill(fT0);
      bin = gLitGs->fHWvlgthCer->Fill(fWvlgth);
      if (gLitCs) {
        bin = gLitCs->fHTimeCer->Fill(fT0);
        bin = gLitCs->fHWvlgthCer->Fill(fWvlgth);
      }
      GenKECer(K,E);
      fPhot = new TLitPhoton(fRun,kphot,fX0,fGeoVolume,fPath.Data(),fWvlgth,fT0,K,E,0);
      //follow the photon from its birth to its death
      fPhot->Move();
      if (gLitGs->fNpAbnorm>TLitPhys::Get()->Anomalies())
        gCleanOut->MM(fatal,met,"Too many anomalies",ClassName());
      delete fPhot;
      fPhot = 0;
    }// end for (kphot=1;kphot<=nphotCer;kphot++)
  }// end if (fParticle->EmitCerenkov())
}
void TLitBeam::Gen(Int_t run, Int_t npart, Double_t xparam, Bool_t runstat,Bool_t forgetlast, Double_t step) {
  //  Starts a run generating npart particles which in turn will generate
  // photons while crossing fluorescent materials. The parameters are the
  // following :
  //
  //  run        : run number. Arbitrary, but has to be greater than 0.
  //
  //  npart      : number of beam particles to be generated in this run.
  //
  //  xparam     : this parameter is used as abscissa in the plotting of the
  //               results by the class TLitMarrow. For instance, if you
  //    have a setup with a crystal and a beam transversed to the axis of the
  //    crystal and you make 10 runs varying the coordinate of the beam along
  //    the axis of the crystal, you can choose this coordinate as xparam. All
  //    plots provided by TLitMarrow will then have this coordinate as x coor-
  //    dinate. You will get efficiency versus beam position along axis of crystal,
  //    and so on. If you do not give xparam, or give a value smaller than -1.0e+20,
  //    all plots of TLitMarrow will have the run number as x coordinate.
  //    The title of class TLitMarrow, pointed to by the global pointer gLitGp,
  //    will help giving a meaningful title to the x axis. For instance, calling:
  //
  //       ==> gLitGp->SetTitle("beam position along axis");
  //
  //   the title of the x axis of the histogram of efficiency will be:
  //
  //       ==> "Efficiency versus beam position along axis"  //
  //
  //  runstat and forgetlast :
  //
  //    if runstat == true [Default] AND forgetlast == false [Default] :
  //
  //      in memory   : this run statistics keeped but this run histos deleted
  //                     when next run begins
  //      on the file : this run statistics and histos recorded
  //
  //            It is the only configuration which allows the working of
  //          TLitMarrow, i.e. allowing to show histograms of quantities
  //          varying as a function of a run dependent parameter.
  //          Usage : normal case : try it first.
  //
  //    if runstat == true AND forgetlast == true :
  //
  //      in memory   : this run statistics and histograms deleted when next
  //                     run begins.
  //      on the file : this run statistics and histos recorded
  //
  //          Disadvantage : TLitMarrow not working, gLitGp pointer unavailable
  //          Advantage    : no increase of memory with runs
  //                         per run histograms still available on file
  //          Usage : use this configuration when your number of runs is big
  //                  but you still want per run statistics and histograms
  //                  on file.
  //
  //    if runstat == false ( forgetlast true or false ) :
  //
  //      in memory   : no statistics and histograms for this run
  //      on the file : no statistics and histograms for this run
  //
  //          Disadvantage : TLitMarrow not working, gLitGp pointer unavailable
  //                         per run statistics and histograms not available
  //          Advantage    : no increase of memory with runs
  //                         a bit faster, half less histograms to fill
  //          Usage : use this configuration when your number of runs is very
  //                  big and you are not interested in the per run statistics
  //                  and histograms.
  //
  //  Notice that in any case, the global statistics and histograms for all
  // runs is always present in memory and on the file. This global statistics
  // is an object of class TLitResults, pointed to by the pointer gLitGs.
  //
  //  step       : step is the distance, in [cm], into which the trajectory of
  //               the particle inside a shape will be cut for generating
  //    photons. Default 0.5 cm. Each time SLitrani enters the next step, it prints
  //    a message about the number of photons If it appears that the user has
  //    choosen step so small that less than 10 dEdx photons are emitted, SLitrani
  //    multiplies step by 10 as many times as necessary to get more than 10 photons.
  //
  const char    *met = "Gen";
  const Double_t eps4 = 1.0e-4;
  Int_t nstep,kstep,bin,kpart;
  Bool_t crossing;
  Double_t diff;
  Double_t length,laststep,cstep;
  Bool_t IsgGpok;
  fRunStat    = runstat;
  fForgetLast = forgetlast;
  if (run<=0) {
    gCleanOut->MM(error,met,"Run number must be >= 1",ClassName());
    gCleanOut->MM(error,met,"Abs() + 1 taken",ClassName());
    run = TMath::Abs(run);
    run += 1;
  }
  fRun = run;
  NameFile();
  gCleanOut->M(info,"");
  gCleanOut->MM(info,met,fFullTitle.Data(),ClassName());
  fStep = step;
  // Initializes the summary statistics of class TLitMarrow
  IsgGpok = (fRunStat && (!fForgetLast));
  if (!gLitGp && IsgGpok) gLitGp = new TLitMarrow("Summary","Runs",IsgGpok);
  if (gLitCs) {
    // If gLitCs is different from 0 here, it is the gLitCs of the previous run
    if (fForgetLast) {
      //  If fForgetLast is true, the gLitCs of the previous run is removed from
      // the collection and then deleted. The content of TLitDetector::fgLitDetRun
      // is also deleted. No increase of memory used from run to run, but statistics
      // calculation at the end only possible by reading the ROOT file
      TLitResults::fgResults->Remove(gLitCs);
      delete gLitCs;
      gLitCs = 0;
    }
    else {
      //  If fForgetLast is false, the variable containing the statistics, like
      // fNpGener,fNpSeen,fNpLossAny,...and so on are preserved, but all histograms
      // are deleted. It is also the case for the detectors in TLitDetector::fgLitDetRun:
      // statistics variable preserved, but histograms deleted. gLitCs of the previous
      // run remains without its histograms inside collection TLitResults::fgResults,
      // allowing statistics calculations at the end of all runs, without opening
      // the ROOT file
      gLitCs->DelHistos();
    }
  }
  gLitCs = 0;
  //  Books a new gLitCs for this run. A new collection of detectors
  // TLitDetector::fgLitDetRun will also be booked
  if (fRunStat) gLitCs = new TLitResults(fFullName.Data(),fFullTitle.Data(),fRun,xparam);
  // Open the .root file for writing, if not yet done
  if (TLit::Get()->fFilesClosed) {
    TLit::Get()->OpenFilesW(fRunStat);
    gROOT->cd();
    if ((!fRunStat) && (gLitCs)) {
      delete gLitCs;
      gLitCs = 0;
    }
  }
  //Big loop on generation of particles
  TLitDetector::fgLastUsedDet = 0;
  for (kpart=1;kpart<=npart;kpart++) {
    StartOneParticle();
    gLitGs->fNbPart++;
    bin = gLitGs->fHPMomentum->Fill(fParticle->GetMomentum());
    bin = gLitGs->fHPTheta->Fill(fTheta);
    if (gLitCs) {
      gLitCs->fNbPart += 1;
      bin = gLitCs->fHPMomentum->Fill(fParticle->GetMomentum());
      bin = gLitCs->fHPTheta->Fill(fTheta);
    }
    // Initialize tracking
    InitTracking();
    crossing = kTRUE;
    while (crossing) {
      if (!fIsdEdx) crossing = NextCrossing();
      else {
        fNextNode  = gGeoManager->FindNextBoundary(TLitPhys::Get()->BiggestStep());
        length     = gGeoManager->GetStep();
        fnCerenkov = fLitMedium->GetnCerenkov();
        nstep      = (Int_t)(length/fStep);
        laststep   = length - nstep*fStep;
        nstep++;
        for (kstep=1;kstep<=nstep;kstep++) {
          if (kstep == nstep) {
            fNextNode = gGeoManager->FindNextBoundary(TLitPhys::Get()->BiggestStep());
            cstep     = gGeoManager->GetStep();
            diff = TMath::Abs(cstep-laststep);
            if (diff>eps4) {
              cstep = laststep;
              gCleanOut->MMR(warning,met,"Bad estimation of step","error",diff,ClassName());
            }
          }
          else cstep = fStep;
          EmitLight(cstep);
          fNextNode = gGeoManager->InitTrack(fX[0],fX[1],fX[2],fDir[0],fDir[1],fDir[2]);
          if (kstep == nstep) NextCrossing();
          else {
            const Double_t *point;
            const Double_t *dir;
            gGeoManager->SetStep(cstep);
            fNextNode = gGeoManager->Step();
            point  = gGeoManager->GetCurrentPoint();
            dir    = gGeoManager->GetCurrentDirection();
            fX.SetXYZ(point[0],point[1],point[2]);
            fDir.SetXYZ(dir[0],dir[1],dir[2]);
            fRoad += cstep;
            fTime += cstep/fParticle->GetSpeed();
          }// end else if (kstep == nstep)
        }//end for (kstep=1;kstep<=nstep;kstep++)
      }//end else if (!fIsdEdx)
    }//end while (crossing)
  }// end for (kpart=1;kpart<=npart;kpart++)
  //Put statistics of this run into the tree.
  if (gLitCs) {
    gLitCs->Conclusion();
    TLit::Get()->fLitFile->cd();
    TLit::Get()->fLitNb += TLit::Get()->fLitTree->Fill();
    gROOT->cd();
  }
}
void TLitBeam::Gen4pi() {
  // Generates fTheta and fPhi according to sin(t)dtdf   0<fTheta<pi
  const Double_t un     = 1.0;
  const Double_t deux   = 2.0;
  Double_t x,y;
  x = gRandom3->Rndm();
  y = un - deux*x;
  fTheta = TLitPhys::ACos(y);
  fPhi   = deux*TMath::Pi()*gRandom3->Rndm();
}
void TLitBeam::GenE(const TVector3& K,TVector3& E) const {
  //  Generates the direction of the E field of the photon generated by the
  // beam particle. Refuses to do it inside anisotropic material, where one is
  // not at all free to choose it in the plane orthogonal to k, but where it
  // is fixed when k is fixed.
  const char *met = "GenE";
  const Double_t zero = 0.0;
  const Double_t deux = 2.0;
  Double_t s,c,phi,x;
  if (!fLitMedium->GetAnisotropy()) {
    TVector3 Ox,Oy;
    s = TMath::Abs(K*fAxisb1);
    c = TMath::Abs(K*fAxisb2);
    if (s<c) Ox = fAxisb1;
    else     Ox = fAxisb2;
    Oy = K.Cross(Ox);
    Oy = Oy.Unit();
    Ox = Oy.Cross(K);
    Ox = Ox.Unit();
    if (TLit::Get()->GetTestCalc()) {
      const Double_t eps = 1.0e-12;
      x = TMath::Abs(Ox*Oy);
      if (x>eps) gCleanOut->MM(error,met,"Ox not orthogonal to Oy",ClassName());
      x = TMath::Abs(Ox*K);
      if (x>eps) gCleanOut->MM(error,met,"Ox not orthogonal to K",ClassName());
      x = TMath::Abs(Oy*K);
      if (x>eps) gCleanOut->MM(error,met,"Oy not orthogonal to K",ClassName());
      x = TMath::Abs(1.0-Ox*(Oy.Cross(K)));
      if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
    }
    phi = deux*TMath::Pi()*gRandom3->Rndm();
    s   = TMath::Sin(phi);
    c   = TMath::Cos(phi);
    E   = c*Ox + s*Oy;
  }
  else E.SetXYZ(zero,zero,zero);
}
void TLitBeam::GenFlat() {
  // Generates fTheta and fPhi according to sin(t)dtdf   0<fTheta<fThetaMax
  const Double_t zero   = 0.0;
  const Double_t un     = 1.0;
  const Double_t deux   = 2.0;
  const Double_t vsmall = 1.0e-14;
  if (fThetaMax<vsmall) fTheta = zero;
  else {
    Double_t x,y;
    x = gRandom3->Rndm();
    y = un - x*(un - fApercos);
    fTheta = TLitPhys::ACos(y);
  }
  fPhi = deux*TMath::Pi()*gRandom3->Rndm();
}
void TLitBeam::GenK(TVector3& K) {
  //  Generates isotropically the direction of the k vector of the photon
  // generated by the beam particle.
  const Double_t un     = 1.0;
  const Double_t deux   = 2.0;
  Double_t theta,phi;
  Double_t x,y,z,st,ct,sf,cf;
  x = gRandom3->Rndm();
  y = un - deux*x;
  theta = TLitPhys::ACos(y);
  phi   = deux*TMath::Pi()*gRandom3->Rndm();
  st = TMath::Sin(theta);
  ct = TMath::Cos(theta);
  sf = TMath::Sin(phi);
  cf = TMath::Cos(phi);
  x  = st*cf;
  y  = st*sf;
  z  = ct;
  K = x*fAxisb1 + y*fAxisb2 + z*fWCSSourceDir;
}
void TLitBeam::GenKECer(TVector3& K,TVector3& E) const {
  // Generates k vector and E field for a Cerenkov photon.
  const char *met = "GenKECer";
  const Double_t zero = 0.0;
  const Double_t deux = 2.0;
  Double_t phi;
  Double_t x,y,z,st,ct,sf,cf,s,c;
  st    = fParticle->CerSin();
  ct    = fParticle->CerCos();
  phi   = deux*TMath::Pi()*gRandom3->Rndm();
  sf = TMath::Sin(phi);
  cf = TMath::Cos(phi);
  x  = st*cf;
  y  = st*sf;
  z  = ct;
  K = x*fAxisb1 + y*fAxisb2 + z*fWCSSourceDir;
  if (!fLitMedium->GetAnisotropy()) {
    TVector3 Ox,Oy;
    s = TMath::Abs(K*fAxisb1);
    c = TMath::Abs(K*fAxisb2);
    if (s<c) Ox = fAxisb1;
    else     Ox = fAxisb2;
    Oy = K.Cross(Ox);
    Oy = Oy.Unit();
    Ox = Oy.Cross(K);
    Ox = Ox.Unit();
    if (TLit::Get()->GetTestCalc()) {
      const Double_t eps = 1.0e-12;
      x = TMath::Abs(Ox*Oy);
      if (x>eps) gCleanOut->MM(error,met,"Ox not orthogonal to Oy",ClassName());
      x = TMath::Abs(Ox*K);
      if (x>eps) gCleanOut->MM(error,met,"Ox not orthogonal to K",ClassName());
      x = TMath::Abs(Oy*K);
      if (x>eps) gCleanOut->MM(error,met,"Oy not orthogonal to K",ClassName());
      x = TMath::Abs(1.0-Ox*(Oy.Cross(K)));
      if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
    }
    phi = deux*TMath::Pi()*gRandom3->Rndm();
    s   = TMath::Sin(phi);
    c   = TMath::Cos(phi);
    E   = c*Ox + s*Oy;
  }
  else E.SetXYZ(zero,zero,zero);
}
Bool_t TLitBeam::GenSourceDir() {
  // Generates the direction of the beam particle
  Double_t x,y,z,st,ct,sf,cf;
  Bool_t ok = kTRUE;
  switch (fKindOfEmission) {
  case on4pi:
    Gen4pi();
    break;
  case flat:
    GenFlat();
    break;
  case sinuscosinus:
    GenSinCos();
    break;
  case provided:
    ok = GenProvided();
    break;
  }
  st = TMath::Sin(fTheta);
  ct = TMath::Cos(fTheta);
  sf = TMath::Sin(fPhi);
  cf = TMath::Cos(fPhi);
  x  = st*cf;
  y  = st*sf;
  z  = ct;
  fSourceDir = x*fAxisDirx + y*fAxisDiry + z*fAxisDirz;
  fSourceDir = fSourceDir.Unit();
  return ok;
}
Bool_t TLitBeam::GenProvided() {
  //  Generates fTheta and fPhi according to provided distribution.
  //    0<fTheta<fThetaMax
  const Double_t zero   = 0.0;
  const Double_t deux   = 2.0;
  const Double_t vsmall = 1.0e-14;
  const Int_t ntrymax   = 1000000;
  Bool_t ok = kTRUE;
  if (fThetaMax<vsmall) fTheta = zero;
  else {
    ok = kFALSE;
    Int_t ntry = 0;
    while ((!ok) && (ntry<ntrymax)) {
      ntry++;
      fTheta = fFitDist->GetRandom();
      if (fTheta<=fThetaMax) ok = kTRUE;
    }
    if (!ok) gCleanOut->MM(fatal,"GenProvided","Problem generating fTheta",ClassName());
  }
  fPhi = deux*TMath::Pi()*gRandom3->Rndm();
  return ok;
}
void TLitBeam::GenSinCos() {
  // Generates fTheta and fPhi according to sin(t)cos(t)dtdf   0<fTheta<fThetaMax
  const Double_t zero   = 0.0;
  const Double_t deux   = 2.0;
  const Double_t vsmall = 1.0e-14;
  if (fThetaMax<vsmall) {
    fTheta = zero;
  }
  else {
    Double_t x,y;
    x = gRandom3->Rndm();
    y = fApersin*TMath::Sqrt(x);
    fTheta = TLitPhys::ASin(y);
  }
  fPhi = deux*TMath::Pi()*gRandom3->Rndm();
}
Bool_t TLitBeam::GenSourcePoint() {
  //  Generates randomly and with equal probability for all positions inside fStartGeoVol
  // a source of emission, except if fSourceFixed is true, in which case takes simply
  // the value already in fSourcePoint.
  Bool_t ok = kTRUE;
  if (!fSourceFixed) {
    const Int_t Nmax = 10000000;
    const char *met = "GenSourcePoint";
    enum KindOfShape {shbox,shtube,sheltu,shother};
    Int_t N;
    Short_t k;
    Double_t dx,dy,dz;
    Double_t x[3];
    Double_t r,phi,r0,r1,r02,r12,xx,a,b;
    Bool_t isin;
    KindOfShape sh;
    TString sn;
    TGeoShape *shape;
    TGeoBBox  *box;
    TGeoTube  *tube;
    TGeoEltu  *eltu;
    shape = fStartGeoVol->GetShape();
    sn    = shape->ClassName();
    if (!sn.CompareTo("TGeoBBox")) sh = shbox;
    else {
      if (!sn.CompareTo("TGeoTube")) sh = shtube;
      else {
        if (!sn.CompareTo("TGeoEltu")) sh = sheltu;
        else                           sh = shother;
      }
    }
    switch (sh) {
      case shbox:
        box = (TGeoBBox*)shape;
        dx = box->GetDX();
        dy = box->GetDY();
        dz = box->GetDZ();
        x[0] = dx*(2*gRandom3->Rndm() - 1.0);
        x[1] = dy*(2*gRandom3->Rndm() - 1.0);
        x[2] = dz*(2*gRandom3->Rndm() - 1.0);
        for (k=0;k<3;k++) fSourcePoint[k] = x[k];
        break;
      case shtube:
        tube = (TGeoTube*)shape;
        r0   = tube->GetRmin();
        r1   = tube->GetRmax();
        dz   = tube->GetDz();
        r02  = r0*r0;
        r12  = r1*r1;
        xx   = gRandom3->Rndm();
        r    = TMath::Sqrt(r02 + (r12-r02)*xx);
        phi  = 2*TMath::Pi()*gRandom3->Rndm();
        fSourcePoint[2] = dz*(2*gRandom3->Rndm() - 1.0);
        fSourcePoint[0] = r*TMath::Cos(phi);
        fSourcePoint[1] = r*TMath::Sin(phi);
        break;
      case sheltu:
        eltu = (TGeoEltu*)shape;
        a    = eltu->GetA();
        b    = eltu->GetB();
        dz   = eltu->GetDz();
        xx   = gRandom3->Rndm();
        r    = TMath::Sqrt(xx);
        phi  = 2*TMath::Pi()*gRandom3->Rndm();
        fSourcePoint[2] = dz*(2*gRandom3->Rndm() - 1.0);
        fSourcePoint[0] = a*r*TMath::Cos(phi);
        fSourcePoint[1] = b*r*TMath::Sin(phi);
        break;
      case shother:
        box = (TGeoBBox*)shape;
        isin = kFALSE;
        dx = box->GetDX();
        dy = box->GetDY();
        dz = box->GetDZ();
        N = 0;
        while ((!isin) && (N<Nmax)) {
          x[0] = dx*(2*gRandom3->Rndm() - 1.0);
          x[1] = dy*(2*gRandom3->Rndm() - 1.0);
          x[2] = dz*(2*gRandom3->Rndm() - 1.0);
          isin = box->Contains(x);
          N++;
        }
        if (!isin) {
          ok = kFALSE;
          gCleanOut->MM(fatal,met,"Impossible to find a point inside TGeoVolume",ClassName());
        }
        else for (k=0;k<3;k++) fSourcePoint[k] = x[k];
        break;
    }//end switch (sh)
  }
  return ok;
}
void TLitBeam::Init() {
  // Initialization. fThetaMax = -1.0 means: "SetEmission has not been called"
  InitP();
  fMoving    = kFALSE;
  fCheckMove = kFALSE;
  fRoad      = 0;
  fStep      = 0;
  fTime      = 0;
  fPath      = "";
  fThetaMax  = -1.0;
  fRun       = -1;
}
void TLitBeam::InitP() {
  // Pointers to 0
  fParticle    = 0;
  fGeoPhysNode = 0;
  fStartGeoVol = 0;
  fStartLitVol = 0;
  fNode        = 0;
  fGeoVolume   = 0;
  fLitVolume   = 0;
  fGeoMedium   = 0;
  fLitMedium   = 0;
  fNextNode    = 0;
  fFitDist     = 0;
  fPhot        = 0;
}
void TLitBeam::InitTracking() {
  //  Initialize tracking. Finds pointer to TGeoVolume and pointer to optical material.
  // Verifies that starting volume is ok.
  //
  const char *met = "InitTracking";
  Bool_t IsLitMedium,outside;
  dEdxMethod ddmet;
  fIsdEdx = kFALSE;
  fX    = fWCSSourcePoint;
  fDir  = fWCSSourceDir;
  fNode = gGeoManager->InitTrack(fX[0],fX[1],fX[2],fDir[0],fDir[1],fDir[2]);
  if (!fNode) gCleanOut->MM(fatal,met,"Particle created outside world",ClassName());
  else {
    outside = gGeoManager->IsOutside();
    if (outside) gCleanOut->MM(fatal,met,"Start tracking outside geometry",ClassName());
    else {
      fGeoVolume  = fNode->GetVolume();
      const char *path = gGeoManager->GetPath();
      fPath = path;
      fLitVolume = (TLitVolume*)fGeoVolume->GetField();
      fGeoMedium = fGeoVolume->GetMedium();
      IsLitMedium = fGeoMedium->InheritsFrom("TLitMedium");
      if (IsLitMedium) {
        fLitMedium = (TLitMedium*)fGeoMedium;
        ddmet = fLitMedium->dEdxActiv();
        fIsdEdx = (ddmet != nodEdx);
      }//end if (IsLitMedium)
    }//end else if (outside)
  }//end else if (!fNode)
}//end InitTracking()
void TLitBeam::MoveCradle(TGeoMatrix *M,Bool_t todraw) {
  // Moves the photon cradle at the new position M
  if (fMoving) {
    fGeoPhysNode->Align(M,0,fCheckMove);
    fStartGeoVol = fGeoPhysNode->GetVolume();
    if (fStartLitVol) fStartLitVol->SetGeoVolume(fStartGeoVol);
    if (todraw) gGeoManager->GetTopVolume()->Draw("");
  }
  else gCleanOut->MM(error,"MoveCradle","Cradle has not been announced as moving",ClassName());
}
void TLitBeam::NameFile() {
  //  Give name and title to the histogram file for one run.
  // The name of the statistics and histograms file for a run is name ( the
  // name you have given in the constructor ) appended with '_'
  // followed by the run number and '.root'.
  //
  fFullName  = GetName();
  fFullTitle = GetTitle();
  TString srun = "";
  if (fRun<10000) srun.Append('0');
  if (fRun<1000) srun.Append('0');
  if (fRun<100) srun.Append('0');
  if (fRun<10) srun.Append('0');
  srun += fRun;
  fFullName.Append('_');
  fFullName.Append(srun);
  fFullTitle.Append(" run ");
  fFullTitle.Append(srun);
}
void TLitBeam::NameFromPath(TString &s) const {
  // Returns name of TGeoVolume of beam cradle using fSourcePath
  Int_t k,N;
  Bool_t found = kFALSE;
  s = "";
  N = fSourcePath.Length();
  k = N-1;
  while ((k>=0) && (!found)) {
    if (fSourcePath[k]=='/') found = kTRUE;
    else k--;
  }
  if (!found) gCleanOut->MM(fatal,"NameFromPath","Bad path name",ClassName());
  k++;
  while ((k<N) && (fSourcePath[k]!='_')) {
    s.Append(fSourcePath[k]);
    k++;
  }
}
Bool_t TLitBeam::NextCrossing() {
  //  Go until next TGeoVolume. Returns true if inside geometry, false if exiting
  // from the geometry.
  Double_t step;
  const Double_t *point;
  const Double_t *dir;
  const char     *path;
  Bool_t outside = kFALSE;
  Bool_t IsLitMedium;
  dEdxMethod ddmet;
  fIsdEdx = kFALSE;
  fNextNode = gGeoManager->FindNextBoundaryAndStep(TLitPhys::Get()->BiggestStep());
  if (!fNextNode) outside = kTRUE;
  else {
    outside = gGeoManager->IsOutside();
    if (!outside) {
      step  = gGeoManager->GetStep();
      fRoad += step;
      point  = gGeoManager->GetCurrentPoint();
      dir    = gGeoManager->GetCurrentDirection();
      fX.SetXYZ(point[0],point[1],point[2]);
      fDir.SetXYZ(dir[0],dir[1],dir[2]);
      fTime      += step/fParticle->GetSpeed();
      fNode       = fNextNode;
      fGeoVolume  = fNode->GetVolume();
      path        = gGeoManager->GetPath();
      fPath       = path;
      fLitVolume  = (TLitVolume*)fGeoVolume->GetField();
      fGeoMedium  = fGeoVolume->GetMedium();
      IsLitMedium = fGeoMedium->InheritsFrom("TLitMedium");
      if (IsLitMedium) {
        fLitMedium = (TLitMedium*)fGeoMedium;
        ddmet = fLitMedium->dEdxActiv();
        fIsdEdx = (ddmet != nodEdx);
      }//end if (IsLitMedium)
    }
  }
  return !outside;
}
void TLitBeam::SetCerenkov(Bool_t cer) {
  //  Put ON or OFF the emission of Cerenkov light by the particle. If you
  // do not call this method, emission of Cerenkov light is ON by default
  if (fParticle) fParticle->SetEmitCerenkov(cer);
}
Bool_t TLitBeam::SetEmission(KindOfDist kind,Double_t tmax,TVector3 dir,
  const char *fitname,Bool_t srcfix,TVector3 source,Bool_t emface,TVector3 dirfce) {
  //  Declares that the TGeoVolume fStartGeoVol is able to emit particles. All points
  // and vectors of this method are given in the local coordinate system of fStartGeoVol.
  //  There are 3 possibilities for the point of emission of particles:
  //
  //  (1) -  particles are emitted from any point inside the TGeoVolume with an equal
  //         probability
  //  (2) -  [if srcfix true]: all particles are emitted from point "source" inside
  //         the TGeoVolume
  //  (3) -  [if emface true and srcfix false]: first, a point is generated inside
  //         the TGeoVolume with an equal probability. Then the point is translated
  //         inside the TGeoVolume, along direction dirfce, until the edge of the
  //         TGeoVolume. It is the way SLitrani generates surface emission, without
  //         having [as the old Litrani] any handling of faces. This method has the
  //         advantage of working, whatever the kind of TGeoVolume.
  //         
  //  Arguments:
  //
  // kind   : type of distribution for the direction of the emitted particles around dir
  //          [default flat]
  //
  //        on4pi        ==> particles are emitted isotropically, with the distribution
  //                      sin(theta)*dtheta*dphi, on 4 pi.
  //        flat         ==> particles are emitted isotropically, with the distribution
  //                      sin(theta)*dtheta*dphi,with theta between 0 and tmax
  //        sinuscosinus ==> particles are emitted with the non isotropic distribution
  //                      sin(theta)*cos(theta)*dtheta*dphi ,with theta between 0 and
  //                      tmax, favouring slightly the forward direction
  //        provided     ==> particles are emitted using the distribution provided
  //                      as a fit of type TSplineFit of name fitname
  //
  // tmax   : maximum value for the theta angle around dir. tmax is given in degree
  //          [default 1°]
  // dir    : axis around which particles are emitted, in local coordinate system of
  //          TGeoVolume [default (0,1,0)
  // fitname: in case kind == provided, name of fit to be used
  //          [default ""]
  // srcfix : if true, all particles are emitted from the fixed point source [ given in
  //          local coordinate system of TGeoVolume ] inside TGeoVolume
  //          [default false]
  // source : if srcfix true, fixed point in LCS within the TGeoVolume from which all
  //          particles are emitted. if srcfix false, irrelevant. Default (0,0,0)
  // emface : if true and srcfix false, particles are emitted from a face of the TGeoVolume
  //          according to possibility (3) described above. Default true.
  // dirfce : after having generated with equal probability a point anywhere inside the
  //          TGeoVolume, the point is translated along direction "dirfce" until the
  //          edge of the TGeoVolume. Default (0,1,0)
  //
  const Double_t eps   = 1.0e-20;
  const Double_t pideg = 180.0;
  const char *met = "SetEmission";
  Bool_t ok = kTRUE;
  Short_t k;
  Double_t L,x,y;
  fIsdEdx = kTRUE;
  fKindOfEmission = kind;
  fFromFace = kFALSE;
  tmax = TMath::Abs(tmax);
  if (tmax > pideg) tmax = pideg;
  fThetaMax = (tmax*TMath::Pi())/pideg;
  fApersin  = TMath::Sin(fThetaMax);
  fApercos  = TMath::Cos(fThetaMax);
  L = dir.Mag2();
  if (L<eps) {
    dir[0] = 0.0;
    dir[1] = 1.0;
    dir[2] = 0.0;
  }
  fAxisDirz = dir;
  fAxisDirz = fAxisDirz.Unit();
  fAxisDirx.SetXYZ(1.0,0.0,0.0);
  fAxisDiry.SetXYZ(0.0,1.0,0.0);
  x = TMath::Abs(fAxisDirx*fAxisDirz);
  y = TMath::Abs(fAxisDiry*fAxisDirz);
  if (x<=y) {
    fAxisDiry = fAxisDirz.Cross(fAxisDirx);
    fAxisDiry = fAxisDiry.Unit();
    fAxisDirx = fAxisDiry.Cross(fAxisDirz);
    fAxisDirx = fAxisDirx.Unit();
  }
  else {
    fAxisDirx = fAxisDirz.Cross(fAxisDiry);
    fAxisDirx = fAxisDirx.Unit();
    fAxisDiry = fAxisDirz.Cross(fAxisDirx);
    fAxisDiry = fAxisDiry.Unit();
  }
  if (TLit::Get()->GetTestCalc()) {
    const Double_t eps = 1.0e-12;
    x = TMath::Abs(fAxisDirx*fAxisDiry);
    if (x>eps) gCleanOut->MM(error,met,"fAxisDirx not orthogonal to fAxisDiry",ClassName());
    x = TMath::Abs(fAxisDirx*fAxisDirz);
    if (x>eps) gCleanOut->MM(error,met,"fAxisDirx not orthogonal to fAxisDirz",ClassName());
    x = TMath::Abs(fAxisDiry*fAxisDirz);
    if (x>eps) gCleanOut->MM(error,met,"fAxisDiry not orthogonal to fAxisDirz",ClassName());
    x = TMath::Abs(1.0-fAxisDirx*(fAxisDiry.Cross(fAxisDirz)));
    if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
  }
  L = dirfce.Mag2();
  if (L<eps) {
    dirfce[0] = 0.0;
    dirfce[1] = 1.0;
    dirfce[2] = 0.0;
  }
  fDirFace = dirfce;
  fDirFace = fDirFace.Unit();
  fDistName = fitname;
  fFitDist = 0;
  TSplineFit *fit = 0;
  Int_t NL = fDistName.Length();
  if (NL>5) {
    fit = TSplineFit::FindFit(fitname,12);
    if (!fit) gCleanOut->MM(error,met,"Fit not found",ClassName());
  }
  if (fit) {
    if (fKindOfEmission == provided) fFitDist = fit;
    else {
      ok = kFALSE;
      gCleanOut->MM(error,met,"Fit provided but kind of emission != provided",ClassName());
    }
  }
  else {
    if (fKindOfEmission == provided) {
      ok = kFALSE;
      gCleanOut->MM(error,met,"Kind of emission == provided, but fit missing",ClassName());
      gCleanOut->MM(error,met,"We change kind of emission to flat !",ClassName());
      fKindOfEmission = flat;
    }
  }
  fSourceFixed = srcfix;
  if (fSourceFixed) {
    Double_t x[3];
    fSourcePoint = source;
    for (k=0;k<3;k++) x[k] = fSourcePoint[k];
    if (!fGeoVolume->Contains(x)) {
      ok = kFALSE;
      gCleanOut->MM(error,met,"Given fixed point is not inside TGeoVolume",ClassName());
      gCleanOut->MM(error,met,"We switch to no fix point generation",ClassName());
      fSourceFixed = kFALSE;
    }
  }//end if (fSourceFixed)
  else {
    if (emface) fFromFace = kTRUE;
  }//end else if (fSourceFixed)
  return ok;
}
void TLitBeam::SetParticle(TLitParticle *part,Bool_t deleteold) {
  //  Replaces TLitParticle used by an other one. If deleteold is true, deletes
  // the old one. Default false.
  if (deleteold) {
    if (fParticle) {
      delete fParticle;
      fParticle = 0;
    }
  }
  if (!part) fParticle = new TLitParticle(13);
  else       fParticle = part;
}
Bool_t TLitBeam::StartOneParticle() {
  //  Generates a particle conform to all characteristics provided in the cons-
  // tructor and in the method SetEmission().
  //  Generates momentum, calculates speed and energy, generates source point
  // and direction, calculates 3 components of momentum.
  Bool_t ok = kTRUE;
  Bool_t outside;
  Bool_t IsLitMedium;
  dEdxMethod ddmet;
  fParticle->GenP();
  ok = GenSourcePoint();
  if (ok) {
    ok = GenSourceDir();
    if (ok) {
      ok = EmissionToWCS();
      if (ok) {
        fTime = 0;
        outside     = gGeoManager->IsOutside();
        fGeoVolume  = fNode->GetVolume();
        fLitVolume  = (TLitVolume*)fGeoVolume->GetField();
        fGeoMedium  = fGeoVolume->GetMedium();
        fIsdEdx     = kFALSE;
        IsLitMedium = fGeoMedium->InheritsFrom("TLitMedium");
        if (IsLitMedium) {
          fLitMedium = (TLitMedium*)fGeoMedium;
          ddmet = fLitMedium->dEdxActiv();
          fIsdEdx = (ddmet != nodEdx);
        }//end if (IsLitMedium)
        fParticle->SetLorentzE(fWCSSourceDir.X(),fWCSSourceDir.Y(),fWCSSourceDir.Z(),
          fParticle->GetMomentum());
      }
    }
  }
  if (!ok) gCleanOut->MM(fatal,"StartOneParticle","Method failed",ClassName());
  return ok;
}
void TLitBeam::WandLCerenkov(Double_t &wavelength,Double_t &lifetime) const {
  //  Generates wavelength [nm] and lifetime [ps] for a photon of Cerenkov
  // light !
  //  Wavelength is distributed as 1/(wavelength)^2
  //  I know nothing yet about the time distribution of Cerenkov ligth. I
  // have to read some book on the subject ! For the time being, I set it as
  // immediate.
  //
  const Double_t zero = 0.0;
  Double_t l1,l2; //max and min values for a wavelength
  Double_t x;
  //Wavelength
  l1 = TLitPhys::Get()->MaxWaveL();
  l2 = TLitPhys::Get()->MinWaveL();
  x = gRandom3->Rndm();
  wavelength = (l1*l2)/(l1-x*(l1-l2));
  //Time
  lifetime = zero;
}
