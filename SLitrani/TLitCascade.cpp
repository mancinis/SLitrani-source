// @(#)root/html:$Id: TLitCascade.cpp 2008-06-11
// Author: F.X. Gentit <http://gentit.home.cern.ch/gentit/>

/*************************************************************************
* Copyright (C) Those valid for CNRS software.                          *
*************************************************************************/
#include "TROOT.h"
#include "TFile.h"
#include "TGeoNode.h"
#include "TGeoVolume.h"
#include "TGeoBBox.h"
#include "TGeoManager.h"
#include "TCleanOut.h"
#include "TLit.h"
#include "TLitPhys.h"
#include "TLitMedium.h"
#include "TLitVolume.h"
#include "TLitDetector.h"
#include "TLitResults.h"
#include "TLitMarrow.h"
#include "TLitPhoton.h"
#include "TLitCascade.h"

ClassImp(TLitCascade)
//______________________________________________________________________________
//
//  TLitCascade defines an electromagnetic shower, generated by a gamma or an e+
// or an e-, propagating inside a given TLitMedium fRefLitMedium. All TGeoVolumes
// of the setup containing this fRefLitMedium will be affected by the cascade [ i.e.
// will generate light]. But all OTHER TGeoVolumes NOT containing this TLitMedium will
// NOT generate light, EVEN if they contain a TLitMedium able to generate light!
// Be aware of this limitation of TLitCascade! It is better to restrict the use
// of TLitCascade for the cases where the whole shower is almost contained in
// only one TGeoVolume.
//  With the constructors 1 and 2, the "path" of the TGeoVolume in which the cascade
// is generated is provided. The coordinates of the starting point and of the axis
// of the cascade are then given IN THE LOCAL COORDINATE SYSTEM of this TGeoVolume.
//  With the constructors 3 and 4, the "path" of the TGeoVolume in which the cascade
// is generated is NOT provided. The coordinates of the starting point and of the axis
// of the cascade are then given IN THE WORLD COORDINATE SYSTEM.
//  Choose the case most suited to your setup.
//
// PHYSICAL CHARACTERISTICS
//
//  ( 1) The energy of the cascade is E0
//  ( 2) y == E0/Ec , Ec being the critical energy of the material associa-
//         ted with the cascade.
//  ( 3) The longitudinal profile of the cascade is according to the formu-
//         la (23.25), page 148, of the "Review of Particle Physics" :
//
//            dE/dt = (E0*b*((bt)^(a-1))*exp(-bt))/Gamma(a)
//
//  ( 4) b is taken equal to 0.5
//  ( 5) tmax == ln(y) +Cj   [Cj = +0.5 for gamma, -0.5 for electron indu-
//          ced cascades ]
//  ( 6) a is obtained from tmax == (a-1)/b
//  ( 7) The longitudinal spread of the cascade is stopped abruptly after
//         TLitCascade::fZmaxLR = 24 radiations lengths. This value can be
//         changed by the user, TLitCascade::fZmaxLR is public
//  ( 8) The lateral spread of the cascade is taken as (23.27) :
//
//           f(r) = (K^2/pi)/(r^2 + K^2)^2)
//
//        such that :
//
//           Integral[f(r)*r*dr*dphi] == 1
//
//  ( 9) K is chosen such that 90% of the energy is contained in 1 Moliere
//         radius Rm, which gives K = Rm/3 .
//  (10) The lateral spread of the cascade is stopped abruptly at r TLitCascade::
//         fRmaxMR = 3.5 Moliere radius. This value can be changed by the user,
//         TLitCascade::fRmaxMR is public
//

Double_t TLitCascade::fZmaxLR   = 24.0;
Double_t TLitCascade::fRmaxMR   =  3.5;

TLitCascade::TLitCascade(const char *name, const char *title,const char *path,
  const char *namemed,Int_t pdg,Double_t E0,TVector3 StartCasc, TVector3 AxisCasc,
  Double_t photfac) {
  //
  // PARAMETERS OF THE CONSTRUCTOR : BEWARE: POSITIONS IN LCS !
  //
  //  name      : name  of this electromagnetic shower
  //  title     : title of this electromagnetic shower
  //  path      : path name of the TGeoVolume containing the starting point of
  //              the cascade, not necessarily containing TLitMedium namemed:
  //              one can start the cascade outside the TGeoVolume(s) where it
  //              produces light.
  //  namemed   : Name of ONLY TLitMedium inside which TLitCascade will generate light.
  //              All TGeoVolumes NOT containing this TLitMedium "namemed" will
  //              NOT generate light, EVEN if they contain a TLitMedium able to
  //              generate light! The TGeoVolume pointed to by "path" is not
  //              necessary filled with "litmedium". One can start the cascade
  //              outside the TGeoVolume into which it will be activ.
  //  pdg       : pdg code of particle generating the cascade, as defined in
  //              $ROOTSYS/etc/pdg_table.txt. The only pdg codes accepted are:
  //                -11 ==> e+   +11 ==> e-   +22 ==> gamma
  //              [ default 22 ]
  //  E0        : energy [Gev] of the cascade. Will be transformed into Mev
  //              [ default 100.0 Gev ]
  //  StartCasc : Starting point of the cascade, IN THE LOCAL COORDINATES of
  //              the TGeoVolume pointed to by "path".
  //              [ default bottom center of TGeoVolume pointed to by "path" ]
  //  AxisCasc  : axis of the cascade, pointing from start to end, IN THE
  //              LOCAL COORDINATES of the TGeoVolume pointed to by "path".
  //              [ default (0,0,1) ]
  //  photfac  :  Due to the fact that the number of photons generated by an
  //              electromagnetic shower is fantastically high, each job using
  //              SLitrani for generating electromagnetic showers would take
  //              hours or even days to accomplish. You have the possibility,
  //              using photfac, to reduce the number of emitted photons by
  //              photfac to save time. But be aware that you degrade by
  //              that the representation of the cascade. With a very small
  //              value of photfac, most of the volume elements used to build
  //              the cascade will generate 0 photons ! The default of 0.05
  //              has to be considered as a lower limit for a shower of 10 Gev
  //              in a material producing 100 photons per Mev.
  //              [ Default 0.05 ]
  //
  const char *met = "TLitCascade";
  const Double_t zero = 0.0;
  Int_t nstep;
  Double_t tmax,y;
  Double_t phottot,photres,photvol;
  InitP();
  fName    = name;
  fTitle   = title;
  fPhotFac = TMath::Abs(photfac);
  fNStepL  = 100;
  fNStepR  = 35;
  fNStepF  = 120;
  fRun = -1;
  if (!gLitGs)
    gLitGs = new TLitResults("GlobStat","Global statistics of all runs",0);
  FirstStep();
  NewPosition(path,StartCasc,AxisCasc);
  fRefLitMedium = TLitMedium::FindLitMedium(namemed);
  if (!fRefLitMedium) gCleanOut->MM(fatal,met,"Reference TLitMedium not found",ClassName());
  if (!((pdg==-11) || (pdg==11) || (pdg==22))) {
    gCleanOut->MM(error,met,"Bad pdg code. 22 = gamma set",ClassName());
    pdg = 22;
  }
	SetPdgCode(pdg);
  NewEnergy(E0);
  if (pdg==22) fCj =  0.5;
  else         fCj = -0.5;
  fX0      = fRefLitMedium->GetX0();
  fRm      = fRefLitMedium->GetRm();
  fEc      = fRefLitMedium->GetEc();
  if ((fX0<=zero) || (fRm<=zero) || (fEc<=zero)) {
    gCleanOut->MM(error,met,"TLitMedium not initialized for cascades",ClassName());
    gCleanOut->MM(fatal,met,"Please call TLitMedium::SetCascades",ClassName());
  }
  fZmax    = fZmaxLR*fX0;
  fRmax    = fRmaxMR*fRm;
  fB       = 0.5;
  y        = fE0/fEc;
  tmax     = TMath::Log(y) + fCj;
  fA       = fB*tmax + 1.0;
  fK       = fRm/3.0;
  fFacdEdz = (fE0*fB)/(fX0*TMath::Gamma(fA));
  fFacdEdr = (fK*fK)/TMath::Pi();
  fDStepL  = fZmax/fNStepL;
  fDStepR  = fRmax/fNStepR;
  fDStepF  = (2*TMath::Pi())/fNStepF;
  //
  nstep    = fNStepL*fNStepR*fNStepF;
  phottot  = fE0*fRefLitMedium->GetPhotMev();
  photres  = phottot*fPhotFac;
  photvol  = photres/nstep;
  InitPrint(nstep,phottot,photres,photvol);
}
TLitCascade::TLitCascade(const char *name, const char *title,const char *path,
  TLitMedium *refmed,Int_t pdg,Double_t E0,TVector3 StartCasc, TVector3 AxisCasc,
  Double_t photfac) {
  //
  // PARAMETERS OF THE CONSTRUCTOR : BEWARE: POSITIONS IN LCS !
  //
  //  name      : name  of this electromagnetic shower
  //  title     : title of this electromagnetic shower
  //  path      : path name of the TGeoVolume containing the starting point of
  //              the cascade, not necessarily containing TLitMedium refmed:
  //              one can start the cascade outside the TGeoVolume(s) where it
  //              produces light.
  //  refmed    : ONLY TLitMedium inside which TLitCascade will generate light.
  //              All TGeoVolumes NOT containing this TLitMedium "refmed" will
  //              NOT generate light, EVEN if they contain a TLitMedium able to
  //              generate light! The TGeoVolume pointed to by "path" is not
  //              necessary filled with "litmedium". One can start the cascade
  //              outside the TGeoVolume into which it will be activ.
  //  pdg       : pdg code of particle generating the cascade, as defined in
  //              $ROOTSYS/etc/pdg_table.txt. The only pdg codes accepted are:
  //                -11 ==> e+   +11 ==> e-   +22 ==> gamma
  //              [ default 22 ]
  //  E0        : energy [Gev] of the cascade. Will be transformed into Mev
  //  StartCasc : Starting point of the cascade, IN THE LOCAL COORDINATES of
  //              the TGeoVolume pointed to by "path".
  //              [ default bottom center of TGeoVolume pointed to by "path" ]
  //  AxisCasc  : axis of the cascade, pointing from start to end, IN THE
  //              LOCAL COORDINATES of the TGeoVolume pointed to by "path".
  //              [ default (0,0,1) ]
  //  photfac  :  Due to the fact that the number of photons generated by an
  //              electromagnetic shower is fantastically high, each job using
  //              SLitrani for generating electromagnetic showers would take
  //              hours or even days to accomplish. You have the possibility,
  //              using photfac, to reduce the number of emitted photons by
  //              photfac to save time. But be aware that you degrade by
  //              that the representation of the cascade. With a very small
  //              value of photfac, most of the volume elements used to build
  //              the cascade will generate 0 photons ! The default of 0.05
  //              has to be considered as a lower limit for a shower of 10 Gev
  //              in a material producing 100 photons per Mev.
  //              [ Default 0.05 ]
  //
  const char *met = "TLitCascade";
  const Double_t zero = 0.0;
  Int_t nstep;
  Double_t phottot,photres,photvol;
  Double_t tmax,y;
  InitP();
  fName    = name;
  fTitle   = title;
  fPhotFac = TMath::Abs(photfac);
  fNStepL  = 100;
  fNStepR  = 35;
  fNStepF  = 120;
  fRun = -1;
  if (!gLitGs)
    gLitGs = new TLitResults("GlobStat","Global statistics of all runs",0);
  FirstStep();
  NewPosition(path,StartCasc,AxisCasc);
  fRefLitMedium = refmed;
  if (!fRefLitMedium) gCleanOut->MM(fatal,met,"refmed is 0",ClassName());
  if (!((pdg==-11) || (pdg==11) || (pdg==22))) {
    gCleanOut->MM(error,met,"Bad pdg code. 22 = gamma set",ClassName());
    pdg = 22;
  }
	SetPdgCode(pdg);
  NewEnergy(E0);
  if (pdg==22) fCj =  0.5;
  else         fCj = -0.5;
  fX0      = fRefLitMedium->GetX0();
  fRm      = fRefLitMedium->GetRm();
  fEc      = fRefLitMedium->GetEc();
  if ((fX0<=zero) || (fRm<=zero) || (fEc<=zero)) {
    gCleanOut->MM(error,met,"TLitMedium not initialized for cascades",ClassName());
    gCleanOut->MM(fatal,met,"Please call TLitMedium::SetCascades",ClassName());
  }
  fZmax    = fZmaxLR*fX0;
  fRmax    = fRmaxMR*fRm;
  fB       = 0.5;
  y        = fE0/fEc;
  tmax     = TMath::Log(y) + fCj;
  fA       = fB*tmax + 1.0;
  fK       = fRm/3.0;
  fFacdEdz = (fE0*fB)/(fX0*TMath::Gamma(fA));
  fFacdEdr = (fK*fK)/TMath::Pi();
  fDStepL  = fZmax/fNStepL;
  fDStepR  = fRmax/fNStepR;
  fDStepF  = (2*TMath::Pi())/fNStepF;
  //
  nstep    = fNStepL*fNStepR*fNStepF;
  phottot  = fE0*fRefLitMedium->GetPhotMev();
  photres  = phottot*fPhotFac;
  photvol  = photres/nstep;
  InitPrint(nstep,phottot,photres,photvol);
}
TLitCascade::TLitCascade(const char *name, const char *title,const char *namemed,
  TVector3 StartCasc, TVector3 AxisCasc,Int_t pdg,Double_t E0,Double_t photfac) {
  //
  // PARAMETERS OF THE CONSTRUCTOR : BEWARE: POSITIONS IN WCS !
  //
  //  name      : name  of this electromagnetic shower
  //  title     : title of this electromagnetic shower
  //  namemed   : Name of ONLY TLitMedium inside which TLitCascade will generate light.
  //              All TGeoVolumes NOT containing this TLitMedium "namemed" will
  //              NOT generate light, EVEN if they contain a TLitMedium able to
  //              generate light!
  //  StartCasc : Starting point of the cascade, IN THE WORLD COORDINATES SYSTEM
  //  AxisCasc  : axis of the cascade, pointing from start to end, IN THE
  //              WORLD COORDINATE SYSTEM
  //              [ default (0,0,1) ]
  //  pdg       : pdg code of particle generating the cascade, as defined in
  //              $ROOTSYS/etc/pdg_table.txt. The only pdg codes accepted are:
  //                -11 ==> e+   +11 ==> e-   +22 ==> gamma
  //              [ default 22 ]
  //  E0        : energy [Gev] of the cascade. Will be transformed into Mev
  //              [ default 100.0 Gev ]
  //  photfac  :  Due to the fact that the number of photons generated by an
  //              electromagnetic shower is fantastically high, each job using
  //              SLitrani for generating electromagnetic showers would take
  //              hours or even days to accomplish. You have the possibility,
  //              using photfac, to reduce the number of emitted photons by
  //              photfac to save time. But be aware that you degrade by
  //              that the representation of the cascade. With a very small
  //              value of photfac, most of the volume elements used to build
  //              the cascade will generate 0 photons ! The default of 0.05
  //              has to be considered as a lower limit for a shower of 10 Gev
  //              in a material producing 100 photons per Mev.
  //              [ Default 0.05 ]
  //
  const char *met = "TLitCascade";
  const Double_t zero = 0.0;
  Int_t nstep;
  Double_t tmax,y;
  Double_t phottot,photres,photvol;
  InitP();
  fName    = name;
  fTitle   = title;
  fPhotFac = TMath::Abs(photfac);
  fNStepL  = 100;
  fNStepR  = 35;
  fNStepF  = 120;
  fRun = -1;
  if (!gLitGs)
    gLitGs = new TLitResults("GlobStat","Global statistics of all runs",0);
  FirstStep();
  NewPosition(StartCasc,AxisCasc);
  fRefLitMedium = TLitMedium::FindLitMedium(namemed);
  if (!fRefLitMedium) gCleanOut->MM(fatal,met,"Reference TLitMedium not found",ClassName());
  if (!((pdg==-11) || (pdg==11) || (pdg==22))) {
    gCleanOut->MM(error,met,"Bad pdg code. 22 = gamma set",ClassName());
    pdg = 22;
  }
	SetPdgCode(pdg);
  NewEnergy(E0);
  if (pdg==22) fCj =  0.5;
  else         fCj = -0.5;
  fX0      = fRefLitMedium->GetX0();
  fRm      = fRefLitMedium->GetRm();
  fEc      = fRefLitMedium->GetEc();
  if ((fX0<=zero) || (fRm<=zero) || (fEc<=zero)) {
    gCleanOut->MM(error,met,"TLitMedium not initialized for cascades",ClassName());
    gCleanOut->MM(fatal,met,"Please call TLitMedium::SetCascades",ClassName());
  }
  fZmax    = fZmaxLR*fX0;
  fRmax    = fRmaxMR*fRm;
  fB       = 0.5;
  y        = fE0/fEc;
  tmax     = TMath::Log(y) + fCj;
  fA       = fB*tmax + 1.0;
  fK       = fRm/3.0;
  fFacdEdz = (fE0*fB)/(fX0*TMath::Gamma(fA));
  fFacdEdr = (fK*fK)/TMath::Pi();
  fDStepL  = fZmax/fNStepL;
  fDStepR  = fRmax/fNStepR;
  fDStepF  = (2*TMath::Pi())/fNStepF;
  //
  nstep    = fNStepL*fNStepR*fNStepF;
  phottot  = fE0*fRefLitMedium->GetPhotMev();
  photres  = phottot*fPhotFac;
  photvol  = photres/nstep;
  InitPrint(nstep,phottot,photres,photvol);
}
TLitCascade::TLitCascade(const char *name, const char *title,TLitMedium *refmed,
  TVector3 StartCasc, TVector3 AxisCasc,Int_t pdg,Double_t E0,Double_t photfac) {
  //
  // PARAMETERS OF THE CONSTRUCTOR : BEWARE: POSITIONS IN WCS !
  //
  //  name      : name  of this electromagnetic shower
  //  title     : title of this electromagnetic shower
  //  refmed    : ONLY TLitMedium inside which TLitCascade will generate light.
  //              All TGeoVolumes NOT containing this TLitMedium "refmed" will
  //              NOT generate light, EVEN if they contain a TLitMedium able to
  //              generate light!
  //  StartCasc : Starting point of the cascade, IN THE WORLD COORDINATES SYSTEM
  //  AxisCasc  : axis of the cascade, pointing from start to end, IN THE
  //              WORLD COORDINATE SYSTEM
  //              [ default (0,0,1) ]
  //  pdg       : pdg code of particle generating the cascade, as defined in
  //              $ROOTSYS/etc/pdg_table.txt. The only pdg codes accepted are:
  //                -11 ==> e+   +11 ==> e-   +22 ==> gamma
  //              [ default 22 ]
  //  E0        : energy [Gev] of the cascade. Will be transformed into Mev
  //              [ default 100.0 Gev ]
  //  photfac  :  Due to the fact that the number of photons generated by an
  //              electromagnetic shower is fantastically high, each job using
  //              SLitrani for generating electromagnetic showers would take
  //              hours or even days to accomplish. You have the possibility,
  //              using photfac, to reduce the number of emitted photons by
  //              photfac to save time. But be aware that you degrade by
  //              that the representation of the cascade. With a very small
  //              value of photfac, most of the volume elements used to build
  //              the cascade will generate 0 photons ! The default of 0.05
  //              has to be considered as a lower limit for a shower of 10 Gev
  //              in a material producing 100 photons per Mev.
  //              [ Default 0.05 ]
  //
  const char *met = "TLitCascade";
  const Double_t zero = 0.0;
  Int_t nstep;
  Double_t tmax,y;
  Double_t phottot,photres,photvol;
  InitP();
  fName    = name;
  fTitle   = title;
  fPhotFac = TMath::Abs(photfac);
  fNStepL  = 100;
  fNStepR  = 35;
  fNStepF  = 120;
  fRun = -1;
  if (!gLitGs)
    gLitGs = new TLitResults("GlobStat","Global statistics of all runs",0);
  FirstStep();
  NewPosition(StartCasc,AxisCasc);
  fRefLitMedium = refmed;
  if (!fRefLitMedium) gCleanOut->MM(fatal,met,"Reference TLitMedium not provided",ClassName());
  if (!((pdg==-11) || (pdg==11) || (pdg==22))) {
    gCleanOut->MM(error,met,"Bad pdg code. 22 = gamma set",ClassName());
    pdg = 22;
  }
	SetPdgCode(pdg);
  NewEnergy(E0);
  if (pdg==22) fCj =  0.5;
  else         fCj = -0.5;
  fX0      = fRefLitMedium->GetX0();
  fRm      = fRefLitMedium->GetRm();
  fEc      = fRefLitMedium->GetEc();
  if ((fX0<=zero) || (fRm<=zero) || (fEc<=zero)) {
    gCleanOut->MM(error,met,"TLitMedium not initialized for cascades",ClassName());
    gCleanOut->MM(fatal,met,"Please call TLitMedium::SetCascades",ClassName());
  }
  fZmax    = fZmaxLR*fX0;
  fRmax    = fRmaxMR*fRm;
  fB       = 0.5;
  y        = fE0/fEc;
  tmax     = TMath::Log(y) + fCj;
  fA       = fB*tmax + 1.0;
  fK       = fRm/3.0;
  fFacdEdz = (fE0*fB)/(fX0*TMath::Gamma(fA));
  fFacdEdr = (fK*fK)/TMath::Pi();
  fDStepL  = fZmax/fNStepL;
  fDStepR  = fRmax/fNStepR;
  fDStepF  = (2*TMath::Pi())/fNStepF;
  //
  nstep    = fNStepL*fNStepR*fNStepF;
  phottot  = fE0*fRefLitMedium->GetPhotMev();
  photres  = phottot*fPhotFac;
  photvol  = photres/nstep;
  InitPrint(nstep,phottot,photres,photvol);
}
TLitCascade::~TLitCascade() {
  //  Destructor. TLitCascade is only owner of fPhot
  if (fPhot) {
    delete fPhot;
    fPhot = 0;
  }
}
void TLitCascade::CoordStep() {
  //  Finds the coordinates of the volume element (fIStepL,fIStepR,fIStepF),
  // first in cascade coordinate system and then in WCS. Result is set into
  // (fXdv,fYdv,fZdv)
  const Double_t z05 = 0.5;
  TVector3 p;
  Double_t x;     //Coord x of volume element in coord. sys. of cascade
  Double_t y;     //Coord y of volume element in coord. sys. of cascade
  fZcasc = fDStepL*(fIStepL + z05);
  fRcasc = fDStepR*(fIStepR + z05);
  fFcasc = fDStepF*(fIStepF + z05);
  x      = fRcasc*TMath::Cos(fFcasc);
  y      = fRcasc*TMath::Sin(fFcasc);
  p      = fWCSStart + x*fWCSXaxis + y*fWCSYaxis + fZcasc*fWCSZaxis;
  fXdV     = p(0);
  fYdV     = p(1);
  fZdV     = p(2);
}
Double_t TLitCascade::DeltaE(Double_t &deltaV) const {
  //  Calculates volume of volume element [deltaV], energy per cm3 [EperV]
  // and energy deposited in the volume element [return value = deltaV*EperV]
  // for the step (fIStepL,fIStepR,fIStepF).
  //
  const Double_t un   = 1.0;
  Double_t E;     //deposited energy in volume element
  Double_t EperV; //Energy per cm3
  Double_t t;     //Coord z of volume element in rad. L for this step
  Double_t dEdz;  //Energy per longitudinal cm (23.25)
  Double_t dEdr;  //Energy per radial cm (23.27)
  Double_t a;
  t      = fZcasc/fX0;
  deltaV = fRcasc*fDStepR*fDStepF*fDStepL; // [rdrdfdz]
  dEdz   = fFacdEdz*TMath::Exp((fA-un)*TMath::Log(fB*t))*TMath::Exp(-fB*t);
  a      = (fRcasc*fRcasc + fK*fK);
  dEdr   = fFacdEdr/(a*a);
  EperV  = dEdz*dEdr;
  E      = EperV*deltaV;
  return E;
}
Bool_t TLitCascade::EmissionToWCS() {
  //  Given a fSourcePath like "/T_1/A_2/B_2", pointing to a particular instance
  // [node] of a TGeoVolume, calculates:
  //
  //  (1) fStart   => fWCSStart  position of emission point in WCS
  //  (2) fZaxis   => fWCSZaxis  direction of emission in WCS
  //
  //  fSourcePath must have been set before calling this method
  //  To be called only AFTER closing of the geometry
  //
  const char *met = "EmissionToWCS";
  const char lim = '/';
  Int_t kk;
  Short_t depth; //depth of fSourcePath
  Short_t k;     //index inside fSourcePath
  Short_t nn;    //next  '/' to be reached
  Short_t n;     //counter of '/' encountered
  Ssiz_t  N;     //Length of string fSourcePath
  Short_t j;
  Bool_t found1 = kFALSE;
  Bool_t found;
  Double_t x,y;
  Double_t local1[3],master1[3];       // for fStart
  Double_t localdir[3],masterdir[3];   // for fZaxis
  TGeoVolume *vol;
  TGeoNode *node;
  TGeoNode *daughter = 0;
  TGeoNode *foundnode[10];
  TObjArray *nodes;
  TString snode,sdaughter;
  depth = TLit::Get()->CheckPath(fSourcePath);
  switch (depth) {
    case 0:
      gCleanOut->MM(fatal,met,"Bad path of Tgeo",ClassName());
      break;
    case 1:
      fWCSStart = fStart;
      fWCSZaxis = fZaxis;
      found1    = kTRUE;
      break;
    default:
      N  = fSourcePath.Length();
      if (fSourcePath(N-1)==lim) fSourcePath.Resize(--N);
      for (k=0;k<3;k++) {
        local1[k]   = fStart[k];
        localdir[k] = fZaxis[k];
      }
      k  = 0;
      n  = 0;
      nn = 2;
      while ((k<N) && (n<nn)) {
        if (fSourcePath(k) == lim) n++;
        k++;
      }
      nn++; 
      vol = gGeoManager->GetTopVolume();
      found = kTRUE;
      while ((found) && (k<N)) {
        snode = "";
        while ((k<N) && (n<nn)) {
          if (fSourcePath(k) == lim) n++;
          else snode.Append(fSourcePath(k)); 
          k++;
        }
        nodes = vol->GetNodes();
        TIter next(nodes);
        found = kFALSE;
        while ((!found) && (node = (TGeoNode*)next())) {
          if (!snode.CompareTo(node->GetName())) {
            daughter = node;
            foundnode[nn-3] = node;
            found = kTRUE;
          }
        }
        if (found) vol = daughter->GetVolume();
        nn++;
      }// end while ((found) && (k<N))
      found1 = found;
      nn -= 3;
      if (found1) {
        for (k=0;k<nn;k++) {
          node = foundnode[nn-k-1];
          node->LocalToMaster(local1,master1);
          node->LocalToMasterVect(localdir,masterdir);
          for (j=0;j<3;j++) {
            local1[j]   = master1[j];
            localdir[j] = masterdir[j];
          }
        }
        for (j=0;j<3;j++) {
          fWCSStart[j] = master1[j];
          fWCSZaxis[j] = masterdir[j];
        }
      }
      break;
  }//end switch (depth)
  //  Generation of a complete coordinate system in WCS, having fWCSZaxis as
  // z axis.
  fWCSZaxis = fWCSZaxis.Unit();
  fWCSXaxis.SetXYZ(1.0,0.0,0.0);
  fWCSYaxis.SetXYZ(0.0,1.0,0.0);
  x = TMath::Abs(fWCSXaxis*fWCSZaxis);
  y = TMath::Abs(fWCSYaxis*fWCSZaxis);
  if (x<=y) {
    fWCSYaxis = fWCSZaxis.Cross(fWCSXaxis);
    fWCSYaxis = fWCSYaxis.Unit();
    fWCSXaxis = fWCSYaxis.Cross(fWCSZaxis);
    fWCSXaxis = fWCSXaxis.Unit();
  }
  else {
    fWCSXaxis = fWCSZaxis.Cross(fWCSYaxis);
    fWCSXaxis = fWCSXaxis.Unit();
    fWCSYaxis = fWCSZaxis.Cross(fWCSXaxis);
    fWCSYaxis = fWCSYaxis.Unit();
  }
  if (TLit::Get()->GetTestCalc()) {
    const Double_t eps = 1.0e-12;
    x = TMath::Abs(fWCSXaxis*fWCSYaxis);
    if (x>eps) gCleanOut->MM(error,met,"fWCSXaxis not orthogonal to fWCSYaxis",ClassName());
    x = TMath::Abs(fWCSXaxis*fWCSZaxis);
    if (x>eps) gCleanOut->MM(error,met,"fWCSXaxis not orthogonal to fWCSZaxis",ClassName());
    x = TMath::Abs(fWCSYaxis*fWCSZaxis);
    if (x>eps) gCleanOut->MM(error,met,"fWCSYaxis not orthogonal to fWCSZaxis",ClassName());
    x = TMath::Abs(1.0-fWCSXaxis*(fWCSYaxis.Cross(fWCSZaxis)));
    if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
  }
  const char *path;
  fStartGeoNode = gGeoManager->InitTrack(fWCSStart[0],fWCSStart[1],fWCSStart[2],
    fWCSZaxis[0],fWCSZaxis[1],fWCSZaxis[2]);
  if (!fStartGeoNode) gCleanOut->MM(fatal,met,"fStartGeoNode not found",ClassName());
  if (gGeoManager->IsOutside())
    gCleanOut->MM(fatal,met,"Starting point outside geometry",ClassName());
  path = gGeoManager->GetPath();
  kk = fSourcePath.CompareTo(path);
  if (kk) {
    found1 = kFALSE;
    gCleanOut->MM(error,met,"User path different from found path",ClassName());
    gCleanOut->MMT(error,met,fSourcePath.Data(),"given by","user",ClassName());
    gCleanOut->MMT(fatal,met,path,"found by","TGeo",ClassName());
  }
  if (!found1) gCleanOut->MM(fatal,met,"EmissionToWCS failed",ClassName());
  return found1;
}
void TLitCascade::EmitLight(Double_t &dE) {
  //  Emit the corrresponding number of photons for a deposited energy of dE Mev
  // inside the volume element pointed to by (fXdV,fYdV,fZdV) in case this volume
  // element contains (even partially) material fRefLitMedium.
  //
  const char *met    = "EmitLight";
  const Double_t eps = 1.0e-20;
  Int_t nphot,nphotin;
  Bool_t IsIn;
  Int_t i,nphot1,nphot2;
  Int_t kfluo,bin;
  Axis_t afluo;
  Double_t x,aphot,rphot;
  TVector3 x0; // Position of generated photon in WCS
  TVector3 K;  // K vector of photon
  TVector3 E;  // E field of photon
  //Number of photons to generate
  nphotin = 0;
  aphot = dE*fPhotFac*fRefLitMedium->GetPhotMev();
  nphot = (Int_t)aphot;
  rphot = aphot - nphot;
  x = gRandom3->Rndm();
  if (x<=rphot) nphot += 1;
  nphot1 = fNphot + 1;
  nphot2 = fNphot + nphot;
  //
  // Loop on generation of photons
  //
  for (i=nphot1;i<=nphot2;i++) {
    GenPositionIndV();
    IsIn = SetGeo();
    if (!IsIn) fNphotOut++;
    else {
      nphotin++;
      fNphot++;
      gLitGs->fNpGener++;
      if (gLitCs) gLitCs->fNpGener++;
      //first determines wavelength and time of emission of photon and store results
      //in histograms
      fRefLitMedium->WaveAndLife(fWvlgth,fT0,kfluo);
      //update all values depending upon wavelength
      TLitMedium::NewWavelengthAll(fWvlgth);
      TLitVolume::NewWavelengthAll(fWvlgth);
      bin = gLitGs->fHTimeAll->Fill(fT0);
      bin = gLitGs->fHWvlgthAll->Fill(fWvlgth);
      if (gLitCs) {
        bin = gLitCs->fHTimeAll->Fill(fT0);
        bin = gLitCs->fHWvlgthAll->Fill(fWvlgth);
      }
      if (gLitGs->HasFluo()) {
        afluo = kfluo;
        bin = gLitGs->fHTimeEach->Fill(fT0,afluo);
        bin = gLitGs->fHWvlgthEach->Fill(fWvlgth,afluo);
      }  //if (gLitGs->HasFluo())
      if ((gLitCs) && (gLitCs->HasFluo())) {
        afluo = kfluo;
        bin = gLitCs->fHTimeEach->Fill(fT0,afluo);
        bin = gLitCs->fHWvlgthEach->Fill(fWvlgth,afluo);
      }  //if (gLitCs)
      //generates the photon
      x0.SetXYZ(fX,fY,fZ);
      GenK(K);
      GenE(K,E);
      fPhot = new TLitPhoton(fRun,fNphot,x0,fGeoVolume,gGeoManager->GetPath(),fWvlgth,fT0,K,E,0);
      //follow the photon from its birth to its death
      fPhot->Move();
      if (gLitGs->fNpAbnorm>TLitPhys::Get()->Anomalies())
        gCleanOut->MM(fatal,met,"Too many anomalies",ClassName());
      delete fPhot;
      fPhot = 0;
    }
  }//end for loop on photons
  aphot = (Double_t)nphot;
  if (aphot<eps) aphot = eps;
  dE   *= (nphotin/aphot);
}
void TLitCascade::FirstStep() {
  //Initializes step counters
  fIStepL   = 0;
  fIStepR   = 0;
  fIStepF   = 0;
  fNphot    = 0;
  fNphotOut = 0;
}
void TLitCascade::Gen(Int_t run, Double_t xparam, Bool_t runstat,Bool_t forgetlast) {
  //  Starts a run generating the photons produced by one cascade in all
  // TGeoVolumes made of the TLitMedium fRefLitMedium declared in the constructor
  // of TLitCascade. For all TGeoVolumes not made of this material, nothing happens.
  //
  //  PARAMETERS :
  //
  //  run        : run number. Arbitrary, but has to be greater than 0.
  //
  //  xparam     : this parameter is used as abscissa in the plotting of the
  //               results by the class TLitMarrow. For instance, if you
  //    have a setup with a crystal and you make 10 runs varying the y coordinate
  //    of the starting point of the cascade, you can choose this y coordinate as
  //    xparam. All plots provided by TLitMarrow will then have this y
  //    coordinate as abscissa. You will get efficiency versus y coordinate of
  //    starting point of cascade, and so on. If you do not give xparam, or give
  //    a value smaller than -1.0e+20, all plots of TLitMarrow will have the run
  //    number as abscissa.
  //    The title of class TLitMarrow, pointed to by the global pointer gLitGp,
  //    will help giving a meaningful title to the x axis. For instance, calling:
  //
  //       ==> gLitGp->SetTitle("y coord. of starting point of cascade");
  //
  //   the title of the x axis of the histogram of efficiency will be:
  //
  //       ==> "Efficiency versus y coord. of starting point of cascade"  //
  //
  //  runstat and forgetlast :
  //
  //    if runstat == true [Default] AND forgetlast == false [Default] :
  //
  //      in memory   : this run statistics keeped but this run histos deleted
  //                     when next run begins
  //      on the file : this run statistics and histos recorded
  //
  //            It is the only configuration which allows the working of
  //          TLitMarrow, i.e. allowing to show histograms of quantities
  //          varying as a function of a run dependent parameter.
  //          Usage : normal case : try it first.
  //
  //    if runstat == true AND forgetlast == true :
  //
  //      in memory   : this run statistics and histograms deleted when next
  //                     run begins.
  //      on the file : this run statistics and histos recorded
  //
  //          Disadvantage : TLitMarrow not working, gLitGp pointer unavailable
  //          Advantage    : no increase of memory with runs
  //                         per run histograms still available on file
  //          Usage : use this configuration when your number of runs is big
  //                  but you still want per run statistics and histograms
  //                  on file.
  //
  //    if runstat == false ( forgetlast true or false ) :
  //
  //      in memory   : no statistics and histograms for this run
  //      on the file : no statistics and histograms for this run
  //
  //          Disadvantage : TLitMarrow not working, gLitGp pointer unavailable
  //                         per run statistics and histograms not available
  //          Advantage    : no increase of memory with runs
  //                         a bit faster, half less histograms to fill
  //          Usage : use this configuration when your number of runs is very
  //                  big and you are not interested in the per run statistics
  //                  and histograms.
  //
  //  Notice that in any case, the global statistics and histograms for all
  // runs is always present in memory and on the file. This global statistics
  // is an object of class TLitResults, pointed to by the pointer gLitGs.
  //
  const char     *met = "Gen";
  const Double_t zero = 0.0;
  Bool_t IsgGpok;
  Double_t dEp;      //Energy deposited in  volume element
  Double_t deltaV;   //Volume of volume element r*dr*df*dz [cm3]
  Double_t Edeposit; //Energy deposited by cascade
  Double_t Vdeposit; //Volume into which energy deposited
  fRunStat    = runstat;
  fForgetLast = forgetlast;
  if (run<=0) {
    gCleanOut->MM(error,met,"Run number must be >= 1",ClassName());
    gCleanOut->MM(error,met,"Abs() + 1 taken",ClassName());
    run = TMath::Abs(run);
    run += 1;
  }
  fRun = run;
  NameFile();
  gCleanOut->M(info,"");
  gCleanOut->MM(info,met,fFullTitle.Data(),ClassName());
  // Initializes the summary statistics of class TLitMarrow
  IsgGpok = (fRunStat && (!fForgetLast));
  if (!gLitGp && IsgGpok) gLitGp = new TLitMarrow("Summary","Runs",IsgGpok);
  if (gLitCs) {
    // If gLitCs is different from 0 here, it is the gLitCs of the previous run
    if (fForgetLast) {
      //  If fForgetLast is true, the gLitCs of the previous run is removed from
      // the collection and then deleted. The content of TLitDetector::fgLitDetRun
      // is also deleted. No increase of memory used from run to run, but statistics
      // calculation at the end only possible by reading the ROOT file
      TLitResults::fgResults->Remove(gLitCs);
      delete gLitCs;
      gLitCs = 0;
    }
    else {
      //  If fForgetLast is false, the variable containing the statistics, like
      // fNpGener,fNpSeen,fNpLossAny,...and so on are preserved, but all histograms
      // are deleted. It is also the case for the detectors in TLitDetector::fgLitDetRun:
      // statistics variable preserved, but histograms deleted. gLitCs of the previous
      // run remains without its histograms inside collection TLitResults::fgResults,
      // allowing statistics calculations at the end of all runs, without opening
      // the ROOT file
      gLitCs->DelHistos();
    }
  }
  gLitCs = 0;
  //  Books a new gLitCs for this run. A new collection of detectors
  // TLitDetector::fgLitDetRun will also be booked
  if (fRunStat) gLitCs = new TLitResults(fFullName.Data(),fFullTitle.Data(),fRun,xparam);
  // Open the .root file for writing, if not yet done
  if (TLit::Get()->fFilesClosed) {
    TLit::Get()->OpenFilesW(fRunStat);
    gROOT->cd();
    if ((!fRunStat) && (gLitCs)) {
      delete gLitCs;
      gLitCs = 0;
    }
  }
  // Emission of light
  Bool_t light;
  Bool_t finished = kFALSE;
  Edeposit = zero;
  Vdeposit = zero;
  TLitDetector::fgLastUsedDet = 0;
  FirstStep();
  while (!finished) {
    CoordStep();
    fX = fXdV;
    fY = fYdV;
    fZ = fZdV;
    light = SetGeo();
    //  We only generate light if the center of the volume element is inside
    // a TGeoVolume containing the TLitMedium fRefLitMedium. If it is not the
    // case, no light generated, even if the volume element is partially inside
    // a TGeoVolume containing the TLitMedium fRefLitMedium. If the center of
    // the volume element is inside a TGeoVolume containing the TLitMedium
    // fRefLitMedium, but the volume element is not fully inside, light will
    // be emitted only by the photons generated inside the good TGeoVolume.
    if (light) {
      dEp = DeltaE(deltaV);
      Vdeposit += deltaV;
      EmitLight(dEp);
      Edeposit += dEp;
    }//end if (light)
    finished = NextStep();
  }//end while (!finished)
  gCleanOut->MM(info,met,"End of generation of cascade",ClassName());
  gCleanOut->MMR(info,met,"Energy deposited [Mev]","Energy",Edeposit,ClassName());
  gCleanOut->MMR(info,met,"Into volume [cm3]","Volume",Vdeposit,ClassName());
  //Put statistics of this run into the tree.
  if (gLitCs) {
    gLitCs->Conclusion();
    TLit::Get()->fLitFile->cd();
    TLit::Get()->fLitNb += TLit::Get()->fLitTree->Fill();
    gROOT->cd();
  }
}
void TLitCascade::GenE(const TVector3& K,TVector3& E) const {
  //  Generates the direction of the E field of the photon in the plane perpendicular
  // to K. Refuses to do it inside anisotropic material, where one is not at all free
  // to choose it in the plane orthogonal to k, but where it is fixed when K is fixed.
  const char *met = "GenE";
  Double_t s,c,phi,x;
  if (!fRefLitMedium->GetAnisotropy()) {
    TVector3 Ox(1.0,0.0,0.0);
    TVector3 Oy(0.0,1.0,0.0);
    s = TMath::Abs(K*Ox);
    c = TMath::Abs(K*Oy);
    if (s>c) Ox = Oy;
    Oy = K.Cross(Ox);
    Oy = Oy.Unit();
    Ox = Oy.Cross(K);
    Ox = Ox.Unit();
    if (TLit::Get()->GetTestCalc()) {
      const Double_t eps = 1.0e-12;
      x = TMath::Abs(Ox*Oy);
      if (x>eps) gCleanOut->MM(error,met,"Ox not orthogonal to Oy",ClassName());
      x = TMath::Abs(Ox*K);
      if (x>eps) gCleanOut->MM(error,met,"Ox not orthogonal to K",ClassName());
      x = TMath::Abs(Oy*K);
      if (x>eps) gCleanOut->MM(error,met,"Oy not orthogonal to K",ClassName());
      x = TMath::Abs(1.0-Ox*(Oy.Cross(K)));
      if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
    }
    phi = 2.0*TMath::Pi()*gRandom3->Rndm();
    s   = TMath::Sin(phi);
    c   = TMath::Cos(phi);
    E   = c*Ox + s*Oy;
  }
  else E.SetXYZ(0.0,0.0,0.0);
}
void TLitCascade::GenK(TVector3 &K) const {
  // Generate isotropically the direction of the K vector of the photon
  Double_t theta,phi;
  Double_t x,y,z,st,ct,sf,cf;
  x = gRandom3->Rndm();
  y = 1.0 - 2.0*x;
  theta = TLitPhys::ACos(y);
  phi   = 2.0*TMath::Pi()*gRandom3->Rndm();
  st = TMath::Sin(theta);
  ct = TMath::Cos(theta);
  sf = TMath::Sin(phi);
  cf = TMath::Cos(phi);
  x  = st*cf;
  y  = st*sf;
  z  = ct;
  K.SetXYZ(x,y,z);
}
void TLitCascade::GenPositionIndV() {
  // Generates a point (fX,fY,fZ) inside volume element whose center is
  // (fXdV,fYdV,fZdV) or in cylindrical coordinates (fRcasc,fFcasc,fZcasc)
  Double_t r1,r2,phi1,phi2,z1,z2;
  Double_t a,b;
  Double_t r,phi,z;
  TVector3 p;
  r1   = fDStepR*fIStepR;
  r2   = fDStepR*(fIStepR + 1);
  phi1 = fDStepF*fIStepF;
  phi2 = fDStepF*(fIStepF + 1);
  z1   = fDStepL*fIStepL;
  z2   = fDStepL*(fIStepL + 1);
  a    = r1*r1;
  b    = r2*r2 - a;
  r    = TMath::Sqrt(b*gRandom3->Rndm() + a);
  phi  = (phi2-phi1)*gRandom3->Rndm() + phi1;
  z    = (z2-z1)*gRandom3->Rndm() + z1;
  a    = r*TMath::Cos(phi);
  b    = r*TMath::Sin(phi);
  // Go from cascade coordinate system to WCS
  p    = fWCSStart + a*fWCSXaxis + b*fWCSYaxis + z*fWCSZaxis;
  fX   = p(0);
  fY   = p(1);
  fZ   = p(2);
}
void TLitCascade::InitP() {
  // Pointers to 0
  fStartGeoNode = 0;
  fStartGeoVol  = 0;
  fRefLitMedium = 0;
  fNode         = 0;
  fGeoVolume    = 0;
  fGeoMedium    = 0;
  fLitMedium    = 0;
  fPhot         = 0;
}
void TLitCascade::InitPrint(Int_t nstep,Double_t phottot,Double_t photres,Double_t photvol) const {
  // Print initial characteristics of cascade
  const char *met = "InitPrint";
  const Double_t limp = 0.1;
  gCleanOut->MMR(info,met,"Energy of cascade [Mev]","Energy",fE0,ClassName());
  gCleanOut->MMI(info,met,"Number of volume elements","nstep",nstep,ClassName());
  gCleanOut->MMR(info,met,"Nb. of photons for full generation","phottot",phottot,ClassName());
  gCleanOut->MMR(info,met,"Nb. of photons for this generation","photres",photres,ClassName());
  gCleanOut->MMR(info,met,"Nb. of photons per volume element","photvol",photvol,ClassName());
  gCleanOut->MMR(info,met,"Diminishing factor photfac","photfac",fPhotFac,ClassName());
  if (photvol<limp) {
    gCleanOut->MM(warning,met,"Please increase photfac",ClassName());
  }
}
void TLitCascade::NameFile() {
  //  Give name fFullName and title fFullTitle for the histogram file for one run.
  // Appends run number to name and title
  fFullName  = fName;
  fFullTitle = fTitle;
  TString srun = "";
  if (fRun<10000) srun.Append('0');
  if (fRun<1000) srun.Append('0');
  if (fRun<100) srun.Append('0');
  if (fRun<10) srun.Append('0');
  srun += fRun;
  fFullName.Append('_');
  fFullName.Append(srun);
  fFullTitle.Append(" run ");
  fFullTitle.Append(srun);
}
void TLitCascade::NameFromPath(TString &s) const {
  // Returns name of TGeoVolume pointed to by fSourcePath
  Int_t k,N;
  Bool_t found = kFALSE;
  s = "";
  N = fSourcePath.Length();
  k = N-1;
  while ((k>=0) && (!found)) {
    if (fSourcePath[k]=='/') found = kTRUE;
    else k--;
  }
  if (!found) gCleanOut->MM(fatal,"NameFromPath","Bad path name",ClassName());
  k++;
  while ((k<N) && (fSourcePath[k]!='_')) {
    s.Append(fSourcePath[k]);
    k++;
  }
}
void TLitCascade::NewEnergy(Double_t E) {
  // Changes the energy of the cascade to E0 [Gev]
  Double_t P,M;
  M   = GetMass();
  P   = TMath::Sqrt(TMath::Abs(E*E - M*M));
  SetMomentum(P*fWCSZaxis.X(),P*fWCSZaxis.Y(),P*fWCSZaxis.Z(),E);
  SetProductionVertex(fWCSStart.X(),fWCSStart.Y(),fWCSStart.Z(),0.0);
  fE0 = 1000*E;
}
void TLitCascade::NewPosition(const char *path,TVector3 StartCasc,TVector3 AxisCasc) {
  //  Changes position or [and] direction of cascade. StartCasc and AxisCasc are given
  // in the local coordinate system of the TGeoVolume pointed to by "path".
  const char *met = "NewPosition";
  const Double_t big  = 9.0e+8;
  const Double_t eps  = 1.0e-8;
  Double_t L;
  TString nameGeoV = "";
  fSourcePath = path;
  NameFromPath(nameGeoV);
  fStartGeoVol = gGeoManager->FindVolumeFast(nameGeoV.Data());
  if (!fStartGeoVol) gCleanOut->MM(fatal,met,"Starting TGeoVolume not found",ClassName());
  fStart = StartCasc;
  L = fStart.Mag();
  if (L>big) {
    TString s;
    Double_t z,dz;
    TGeoBBox *box = (TGeoBBox*)fStartGeoVol->GetShape();
    dz = box->GetDZ();
    z  = -dz + eps;
    fStart.SetXYZ(0.0,0.0,z);
    s = "Inside volume ";
    s.Append(fStartGeoVol->GetName());
    s.Append(" in LCS");
    gCleanOut->MM(info,met,"Default taken for starting point of cascade",ClassName());
    gCleanOut->MM(info,met,s.Data(),ClassName());
    gCleanOut->MMR(info,met,"x coordinate","x",0.0,ClassName());
    gCleanOut->MMR(info,met,"y coordinate","y",0.0,ClassName());
    gCleanOut->MMR(info,met,"z coordinate","z",z,ClassName());
  }
  fZaxis = AxisCasc;
  L = fZaxis.Mag();
  if (L<eps) fZaxis.SetXYZ(0.0,0.0,1.0);
  fZaxis = fZaxis.Unit();
  if (!EmissionToWCS())
    gCleanOut->MM(fatal,met,"EmissionToWCS failed",ClassName());
}
void TLitCascade::NewPosition(TVector3 StartCasc,TVector3 AxisCasc) {
  //  Changes position or [and] direction of cascade. StartCasc and AxisCasc are given
  // here in the WORLD COORDINATE SYSTEM
  const char *met = "NewPosition";
  const Double_t eps  = 1.0e-8;
  Double_t x,y,L;
  fStart = StartCasc;
  gGeoManager->SetCurrentPoint(fStart.X(),fStart.Y(),fStart.Z());
  fStartGeoNode = gGeoManager->FindNode();
  if (!fStartGeoNode) gCleanOut->MM(fatal,met,"fStartGeoNode not found",ClassName());
  if (gGeoManager->IsOutside())
    gCleanOut->MM(fatal,met,"Starting point outside geometry",ClassName());
  fStartGeoVol  = fStartGeoNode->GetVolume();
  if (!fStartGeoVol)  gCleanOut->MM(fatal,met,"fStartGeoVol not found",ClassName());
  const char *path = gGeoManager->GetPath();
  fSourcePath = path;
  fZaxis = AxisCasc;
  L = fZaxis.Mag();
  if (L<eps) fZaxis.SetXYZ(0.0,0.0,1.0);
  fWCSStart = fStart;
  fZaxis    = fZaxis.Unit();
  fWCSZaxis = fZaxis;
  //  Generation of a complete coordinate system in WCS, having fWCSZaxis as
  // z axis.
  fWCSXaxis.SetXYZ(1.0,0.0,0.0);
  fWCSYaxis.SetXYZ(0.0,1.0,0.0);
  x = TMath::Abs(fWCSXaxis*fWCSZaxis);
  y = TMath::Abs(fWCSYaxis*fWCSZaxis);
  if (x<=y) {
    fWCSYaxis = fWCSZaxis.Cross(fWCSXaxis);
    fWCSYaxis = fWCSYaxis.Unit();
    fWCSXaxis = fWCSYaxis.Cross(fWCSZaxis);
    fWCSXaxis = fWCSXaxis.Unit();
  }
  else {
    fWCSXaxis = fWCSZaxis.Cross(fWCSYaxis);
    fWCSXaxis = fWCSXaxis.Unit();
    fWCSYaxis = fWCSZaxis.Cross(fWCSXaxis);
    fWCSYaxis = fWCSYaxis.Unit();
  }
  if (TLit::Get()->GetTestCalc()) {
    const Double_t eps = 1.0e-12;
    x = TMath::Abs(fWCSXaxis*fWCSYaxis);
    if (x>eps) gCleanOut->MM(error,met,"fWCSXaxis not orthogonal to fWCSYaxis",ClassName());
    x = TMath::Abs(fWCSXaxis*fWCSZaxis);
    if (x>eps) gCleanOut->MM(error,met,"fWCSXaxis not orthogonal to fWCSZaxis",ClassName());
    x = TMath::Abs(fWCSYaxis*fWCSZaxis);
    if (x>eps) gCleanOut->MM(error,met,"fWCSYaxis not orthogonal to fWCSZaxis",ClassName());
    x = TMath::Abs(1.0-fWCSXaxis*(fWCSYaxis.Cross(fWCSZaxis)));
    if (x>eps) gCleanOut->MM(error,met,"System not orthonormal",ClassName());
  }
}
Bool_t TLitCascade::NextStep() {
  // Go to next step. Returns true if last step.
  Bool_t last = kFALSE;
  fIStepF++;
  fIStepF %= fNStepF;
  if (!fIStepF) {
    fIStepR++;
    fIStepR %= fNStepR;
    if (!fIStepR) {
      fIStepL++;
      fIStepL %= fNStepL;
      if (!fIStepL) last = kTRUE;
    }
  }
  return last;
}
Bool_t TLitCascade::SetGeo() {
  //  Given point (fX,fY,fZ) in WCS, finds fNode,fGeoVolume,fGeoMedium,fLitMedium.
  // returns true if fLitMedium == fRefLitMedium.
  const char *met = "SetGeo";
  Bool_t IsLitMedium;
  Bool_t light = kFALSE;
  fLitMedium = 0;
  gGeoManager->SetCurrentPoint(fX,fY,fZ);
  fNode = gGeoManager->FindNode();
  if (fNode) {
    if (!gGeoManager->IsOutside()) {
      fGeoVolume = fNode->GetVolume();
      if (fGeoVolume) {
        fGeoMedium = fGeoVolume->GetMedium();
        if (fGeoMedium) {
          IsLitMedium = fGeoMedium->InheritsFrom("TLitMedium");
          if (IsLitMedium) {
            fLitMedium = (TLitMedium*)fGeoMedium;
            light = (fLitMedium==fRefLitMedium);
          }//end if (IsLitMedium)
        }//end if (fGeoMedium)
        else gCleanOut->MM(error,met,"fGeoVolume without fGeoMedium",ClassName());
      }//end if (fGeoVolume)
      else gCleanOut->MM(error,met,"fNode without fGeoVolume",ClassName());
    }//end if (!gGeoManager->IsOutside())
  }//end if (fNode)
  return light;
}
void TLitCascade::SetSteps(Int_t stepl,Int_t stepr,Int_t stepf) {
  // Change values of steps for handling cascade. Call it before Gen().
  fNStepL  = stepl;
  fNStepR  = stepr;
  fNStepF  = stepf;
}
