#include "Riostream.h"
int Nucifer()
{
  cout << endl;
  cout << "Start from Litrani, all libs loaded" << endl;
  cout << endl;
  TLit::Kill();
  //
  // The 7 arguments of the static method TLit::SetParameters() are the following :
  //
  //    size    : size of main canvas of TwoPadDisplay [ 1 <= size <= 8 ]
  //    nbbut   : Number of buttons wanted in TwoPadDisplay. Bigger than 10. [default 24]
  //    xminC   : x coordinate, in pixel, of top left corner of main canvas  [default 2]
  //    yminC   : y coordinate, in pixel, of top left corner of main canvas  [default 2]
  //    WithDate: if true, date and time are appended to the name of the ROOT file
  //              and of the listing, in order not to loose them when starting again
  //              the job.  [default false]     
  //    name    : the name of the .root file that Litrani produces, containing
  //              statistics and histograms of all runs. Do not give the suffix .root.
  //              It will be appended. [default "litrani"]
  //    listing : the name of the .lis file that Litrani produces, containing
  //              messages issued by litrani. Do not give the suffix .lis . It will
  //              be appended.
  //              [default "litrani"] 
  //    ls:     : number of characters in a line of output or listing [default 119]
  //
  cout << "Booking TLit" << endl;
  TLit::SetParameters(4,24,20,2,kFALSE,"Nucifer","Nucifer");
  //  TLit::Get()->SetTesTCalc(kTRUE) asks for many many checks in the computations.
  TLit::Get()->SetTestCalc(kFALSE); //put false when in production mode
  //
  Bool_t prt = kTRUE;  //put kFALSE to suppress printing of geometry sizes
  //
  // Start of Nucifer code
  //
  //  Simulation of PSD in the detector "Nucifer" :
  // We try to determinate the quality of PSD in fonction of wrapping between the
  // tank and the scintillator. So, we create in SLitrani the detector (tank,
  // scintillator, buffer and photodetectors), then we generate into the scintillator
  // two signals. They discribe signals generated by neutrinos and fast neutrons
  // (induice by muons).
  //
  //  Maximum number of output messages
  //
  gCleanOut->fMaxInfo = 1000;
  //
  // Building the geometry
  //
  TGeoManager *geom = new TGeoManager("NUCIFER","NUCIFER");
  //
  // Materials and media
  //
  // (0) Definition of atoms
  //
  TGeoElementTable *table = gGeoManager->GetElementTable();
  TGeoElement *H = table->FindElement("HYDROGEN");
  TGeoElement *C = table->FindElement("CARBON");
  TGeoElement *N = table->FindElement("NITROGEN");
  TGeoElement *O = table->FindElement("OXYGEN");
  Int_t mediumindex = 1;
  const Double_t IrrA   = 0.0;  //Value used for A   when irrelevant !
  const Double_t IrrZ   = 0.0;  //Value used for Z   when irrelevant !
  const Double_t IrrRho = 0.0;  //Value used for Rho when irrelevant !
  //
  // (1) Vacuum for "TOP"
  //
  //  We define here vacuum as a TGeoMedium, not as a TLitMedium, so that photons cannot
  // travel inside it. As by definition photons cannot travel inside top, it is better
  // to not define the medium of TOP as a TLitMedium. Doing so, if a photon happens to
  // be inside top, it will generate an error message from SLitrani.
  //
  TGeoMaterial *vacuum_mat = new TGeoMaterial("Vacuum",IrrA,IrrZ,IrrRho);
  TGeoMedium *vacuum = new TGeoMedium("Vacuum",mediumindex++,vacuum_mat);
  //
  // (2) Nitrogen gaz for "ATM" We define the environnement of Nucifer as a medium
  //                            which is composed only of N2
  //
  const Double_t La_N2 = 350.0; //Absorption length of N2
  const Double_t n_n2  =   1.2; //Refraction index of N2
  TGeoMaterial *n2_mat = new TGeoMaterial("N2",IrrA,IrrZ,IrrRho);
  TLitMedium *n2 = new TLitMedium("N2",mediumindex++,n2_mat,kFALSE,1.0,La_N2);
  n2->IsIsotropic(n_n2);
  //
  // (3) Definition of media of Scintillator
  //
  const Double_t La_scint = 100.0; //Absorption length of liquid scintillator. To be re-
                                   //placed later by true value, depending upon wavelength
  const Double_t n_scint  =  1.49; //Refraction index of liquid scintillator
  TGeoMaterial *scint_mat = new TGeoMaterial("scint",IrrA,IrrZ,IrrRho);
  TLitMedium *scint = new TLitMedium("scint",mediumindex++,scint_mat,kFALSE,1.0,La_scint);
  scint->IsIsotropic(n_scint);
  //
  // (4) Definition of the Spectrum of Scintillator
  //
  // (4.1) Component of Gaussian Distribution of Wavelenght generate by the Scintillator
  //       (in nm)
  const Double_t mean_wl  = 424.0;
  const Double_t sigma_wl = 100.0;
  // (4.2) Component of Time Decay Distribution of the Scintillator
  const Double_t q1 = 0.936, tau1 =   2.1;
  const Double_t q2 = 0.053, tau2 =  14.2;
  const Double_t q3 = 0.011, tau3 = 106.0;
  // (4.3) Definition of the Spectrum
  TLitSpectrum *spectrum = new TLitSpectrum("Spectrum_BC505","Emission Spectrum | BC505");
  spectrum->AddOneComponent(mean_wl,sigma_wl,1.0);
  spectrum->AddTimeComponent(mean_wl,q1,-1.0,tau1);
  spectrum->AddTimeComponent(mean_wl,q2,-1.0,tau2);
  spectrum->AddTimeComponent(mean_wl,q3,-1.0,tau3);
  spectrum->Normalize();
  scint->SetLitSpectrum(spectrum);
  //
  // (5) Definition of media "acrylic" for BUF1 and BUF2. We use as example Polymethyl
  //                                   mathacrylate
  //
  const Double_t La_acrylic = 550.0; //Absorption length of acrylic
  const Double_t n_acrylic  =  1.49; //Index of refraction of acrylic
  TGeoMaterial *acrylic_mat = new TGeoMaterial("Acrylic",IrrA,IrrZ,IrrRho);
  TLitMedium *acrylic = new TLitMedium("Acrylic",mediumindex++,acrylic_mat,kFALSE,1.0,
                                        La_acrylic);
  acrylic->IsIsotropic(n_acrylic);
  //
  // (6) Definition of media "sodocal" of window of PMs..
  //
  const Double_t La_sodocal = 1000.0; //Absorption length of sodocal
  TGeoMaterial *sodocal_mat = new TGeoMaterial("sodocal",IrrA,IrrZ,IrrRho);
  TLitMedium *sodocal = new TLitMedium("sodocal",mediumindex++,sodocal_mat,kFALSE,1.0,
                                       La_sodocal);
  sodocal->IsIsotropic("RefrIndex_Sodocal");
  //
  // (7) Definition of media "cathode" photocathode of PMs. As photons do not enter
  //      inside the volume of the PM, but immediatly stop on the photocathode, the
  //      material of the PM does not matter. So we declare it identical with the
  //      material of the entrance window of the PM, sodocal, so that the transition
  //          window of PM ==> photocathode is immediate. However, we are obliged to
  //      give an other name [here "cathode" instead of "sodocal"] to the TLitMedium
  //      of the photocathode, it has to be declared as "sensible", contrary to the
  //      TlitMedium of the window of the PM
  //
  TLitMedium *cathode = new TLitMedium("cathode",mediumindex++,sodocal_mat,kTRUE,1.0,
                                       La_sodocal);
  cathode->IsIsotropic("RefrIndex_Sodocal");
  //
  // Definitions of wrappings
  //
  //
  // (8) Definition of "WrapTank" : wrapping characteristics of tank
  //                                we have change the name from "TotAbsorbing"
  //                                to "WrapTank" since it is no more a totally
  //                                absorbing wrapping
  //
  const Double_t tank_diffus = 0.1;
  Double_t tank_Rindex       = 0.0;  //will be varied from run to run. 0.0 is not
                                     //a reasonable value, but SLitrani will accept it
  const Double_t tank_Iindex = 1.0;
  const Double_t tank_suppl  = 0.0;
  TGeoMaterial *tank_mat = new TGeoMaterial("WrapTank",IrrA,IrrZ,IrrRho);
  TLitMedium *wraptank = new TLitMedium("WrapTank",mediumindex++,tank_mat,-1.0);
  wraptank->SetAsWrapping(tank_diffus,tank_Rindex,tank_Iindex,1.0,tank_suppl);
  wraptank->IsIsotropic(1.0);  // Only useful if last arg of constructor changed to +1.0
  //
  // (9) Definition of "WrapPM" : a strongly absorbing wrapping around the PMs
  //
  const Double_t wrapPM_diffus = 0.9;
  const Double_t wrapPM_Rindex = 2.5;
  const Double_t wrapPM_Iindex = 1.5;
  const Double_t wrapPM_suppl  = 0.9;
  TGeoMaterial *wrapPM_mat = new TGeoMaterial("WrapPM",IrrA,IrrZ,IrrRho);
  TLitMedium *wrappm = new TLitMedium("WrapPM",mediumindex++,wrapPM_mat,-1.0);
  wrappm->SetAsWrapping(wrapPM_diffus,wrapPM_Rindex,wrapPM_Iindex,1.0,wrapPM_suppl);
  wrappm->IsIsotropic(1.0);  // Only useful if last arg of constructor changed to +1.0
  //
  // Dimensions
  //
  //
  // (1) Dimensions of World
  //
  const Double_t top_dx = 67.0;
  const Double_t top_dy = 67.0;
  const Double_t top_dz = 76.0;
  if (prt) {
    cout << "top_dx     : " << top_dx << endl;
    cout << "top_dy     : " << top_dy << endl;
    cout << "top_dz     : " << top_dz << endl;
  }
  //
  // (2) Dimensions of Tank
  //
  const Double_t tank_r  = top_dx -1.0;
  const Double_t tank_dz = top_dz - 1.0;
  const Double_t roof_dz = 1.0;
  const Double_t base_dz = 1.0;
  if (prt) {
    cout << "tank_r     : " << tank_r  << endl;
    cout << "tank_dz    : " << tank_dz << endl;
    cout << "roof_dz    : " << roof_dz << endl;
    cout << "base_dz    : " << base_dz << endl;
  }
  //
  // (3) Dimensions of atmosphere in the Detector
  //
  const Double_t atm_r   = 65.0;
  const Double_t atm_dz  = 39.0;
  if (prt) {
    cout << "atm_r      : " << atm_r  << endl;
    cout << "atm_dz     : " << atm_dz << endl;
  }
  //
  // (3) Dimensions of the Scintillator
  //
  const Double_t liquid_dz  =  35.0;
  if (prt) cout << "liquid_dz  : " << liquid_dz  << endl;
  //
  // (4) Dimensions of buffer
  //
  const Double_t buf_r   = 63.0;
  const Double_t buf1_dz = 6.5;
  const Double_t buf2_dz = 6.0;
  if (prt) {
    cout << "buf_r      : " << buf_r  << endl;
    cout << "buf1_dz    : " << buf1_dz  << endl;
    cout << "buf2_dz    : " << buf2_dz  << endl;
  }
  //
  // (5) Dimmensions of PhotoDetectors
  //
  const Double_t PMrev_r  = 10.16;
  const Double_t PMrev_dz = 12.5;
  const Double_t PMrev_w  = 0.2;  //width of wrapping around PM
  const Double_t PMwin_r  = PMrev_r - PMrev_w;
  const Double_t PMwin_dz = 0.2;  //thickness of window of PM is 0.4
  const Double_t PM_r     = PMwin_r;
  const Double_t PM_dz = (2*PMrev_dz - PMrev_w - 2*PMwin_dz)/2.0;
  if (prt) {
    cout << "PMrev_r    : " << PMrev_r   << endl;
    cout << "PMrev_dz   : " << PMrev_dz  << endl;
    cout << "PMrev_w    : " << PMrev_w   << endl;
    cout << "PMwin_r    : " << PMwin_r   << endl;
    cout << "PMwin_dz   : " << PMwin_dz  << endl;
    cout << "PM_r       : " << PM_r      << endl;
    cout << "PM_dz      : " << PM_dz     << endl;
  }
  //
  // Positionning (translations)
  //
  //
  // (1) Positionning of PM inside PMrev
  //
  const Double_t t_PM_z = PMrev_dz - PMrev_w - PM_dz;
  TGeoTranslation *t1 = new TGeoTranslation("t1",0.0,0.0,t_PM_z);
  if (prt) cout << "t_PM_z     : " << t_PM_z     << endl;
  //
  // (2) Positionning of PMwin inside PMrev
  //
  const Double_t t_PMwin_z = PMwin_dz - PMrev_dz;
  TGeoTranslation *t2 = new TGeoTranslation("t2",0.0,0.0,t_PMwin_z);
  if (prt) cout << "t_PMwin_z  : " << t_PMwin_z  << endl;
  //
  // (3) Positionning of ATM into the Tank
  //
  const Double_t t_atm_z = tank_dz - roof_dz - atm_dz;
  TGeoTranslation *t3 = new TGeoTranslation("t3",0.0,0.0,t_atm_z);
  if (prt) cout << "t_atm_z    : " << t_atm_z  << endl;
  //
  // (4) Positionning of LIQUID into the Tank
  //
  const Double_t t_liquid_z = - tank_dz + base_dz + liquid_dz;
  TGeoTranslation *t4 = new TGeoTranslation("t4",0.0,0.0,t_liquid_z);
  if (prt) cout << "t_liquid_z : " << t_liquid_z  << endl;
  //
  // (5) Positionning of BUF1 inside ATM
  //
  const Double_t t_buf1_z = -atm_dz + buf1_dz;
  TGeoTranslation *t5 = new TGeoTranslation("t5",0.0,0.0,t_buf1_z);
  if (prt) cout << "t_buf1_z   : " << t_buf1_z  << endl;
  //
  // (6) Positionning of BUF2 inside LIQUID
  //
  const Double_t t_buf2_z = liquid_dz - buf2_dz;
  TGeoTranslation *t6 = new TGeoTranslation("t5",0.0,0.0,t_buf2_z);
  if (prt) cout << "t_buf2_z   : " << t_buf2_z  << endl;
  //
  // (5) Positionning of PMs relative to ATM
  //
  const Double_t t_PMrev_z = -atm_dz + 2*buf1_dz + PMrev_dz;
  const Double_t t_PMrev_x[16] = { 15.37,- 5.87,-19.00,- 5.87, 15.37, 44.00, 37.02, 18.28,- 6.26,-28.81,-42.22,-42.22,-28.81,- 6.26, 18.28, 37.02};
  const Double_t t_PMrev_y[16] = { 11.17, 18.07,   0.0,-18.07,-11.17,   0.0, 23.79, 40.02, 43.55, 33.25, 12.40,-12.40,-33.25,-43.55,-40.02,-23.79};
  TGeoTranslation *tPM[16];
  if (prt) cout << "t_PMrev_z  : " << t_PMrev_z  << endl;
  for (Int_t i=0; i<16; i++) {
    tPM[i] = new TGeoTranslation(Form("tPM %d",i),t_PMrev_x[i],t_PMrev_y[i],t_PMrev_z);
    if (prt) cout << "t_PMrev_xyz: " << t_PMrev_x[i] << "  " << t_PMrev_y[i] << endl;
  }
  //
  // Volumes and Nodes
  //
  //
  // (1) TOP box containing everything and defining the WCS, world coordinate system
  //
  TGeoVolume *top = geom->MakeBox("TOP",vacuum,top_dx,top_dy,top_dz);
  geom->SetTopVolume(top);
  //
  // (2) TGeoTube TANK is a wrapping. It is the container of the Nucifer experiment
  //
  TGeoVolume *tank = geom->MakeTube("TANK",wraptank,0.0,tank_r,tank_dz);
  top->AddNode(tank,1);
  //
  // (3) TGeoTube ATM of Nitrogen in the upper part of TANK
  //
  TGeoVolume *atm = geom->MakeTube("ATM",n2,0.0,atm_r,atm_dz);
  tank->AddNode(atm,1,t3);
  //
  // (4) TGeoTube LIQUID of scintillator in the lower part of TANK
  //
  TGeoVolume *liquid = geom->MakeTube("LIQUID",scint,0.0,atm_r,liquid_dz);
  tank->AddNode(liquid,1,t4);
  TLitVolume *lit_liquid = new TLitVolume(liquid);
  lit_liquid->SetEmission(on4pi);
  //  Notice that we have to define 2 buffers, BUF1 and BUF2, although the content of
  // BUF1 is the same as the content of BUF2. BUF1 is in ATM, BUF2 is in LIQUID. Not
  // doing so would mean extrusion from ATM or from LIQUID, which is forbidden by TGeo
  //  Notice also that the source of photons, LIQUID, has a daughter: BUF2. The photons
  // must come from LIQUID, not from BUF2. Defining a TGeoVolume source of photons
  // which has daughters is now permitted by SLitrani 1.1 and above. It was not the case
  // of SLitrani 1.0.
  //
  // (5) TGeoTube BUF1 in the lower part of ATM
  //
  TGeoVolume *buf1 = geom->MakeTube("BUF1",acrylic,0.0,buf_r,buf1_dz);
  atm->AddNode(buf1,1,t5);
  //
  // (6) TGeoTube BUF2 in the upper part of LIQUID
  //
  TGeoVolume *buf2 = geom->MakeTube("BUF2",acrylic,0.0,buf_r,buf2_dz);
  liquid->AddNode(buf2,1,t6);
  //
  // (7) TGeoTube PMrev is the wrapping surrounding all the PM [except the window
  //                    of the PM]. It is the box containing the phototube
  //
  TGeoVolume *PMrev = geom->MakeTube("PMREV",wrappm,0.0,PMrev_r,PMrev_dz);
  //
  // (8) TGeoTube PMwin is the sodocal window of the PM
  //
  TGeoVolume *PMwin = geom->MakeTube("PMWIN",sodocal,0.0,PMwin_r,PMwin_dz);
  PMrev->AddNode(PMwin,1,t2);
  //
  // (9) TGeoTube PM is the PM itself
  //
  TGeoVolume *PM = geom->MakeTube("PM",cathode,0.0,PM_r,PM_dz);
  PMrev->AddNode(PM,1,t1);
  TLitVolume *Lit_PM = new TLitVolume(PM);
  Lit_PM->SetPhotoTube("QuantumEff_XP2020",1.0);
  for (Int_t i=0; i<16; i++) { atm->AddNode(PMrev,(i+1),tPM[i]); }
  //
  // End of Builing the Geometry
  //
  geom->CloseGeometry();
  geom->CheckOverlaps(0.01);
  //
  // Color and Drawing
  //
  const Color_t color_top    =  0;
  const Color_t color_tank   =  1;
  const Color_t color_atm    =  1;
  const Color_t color_liquid =  7;
  const Color_t color_buf1   =  2;
  const Color_t color_pmrev  =  4;
  const Color_t color_pmwin  =  3;
  const Color_t color_pm     =  8;
  top->SetVisibility(kFALSE);
  top->SetVisContainers();
  tank->SetVisibility(kTRUE);
  tank->SetFillColor(color_tank);
  tank->SetLineColor(color_tank);
  tank->SetLineWidth(1);
  atm->SetVisibility(kTRUE);
  atm->SetFillColor(color_atm);
  atm->SetLineColor(color_atm);
  atm->SetLineWidth(1);
  liquid->SetVisibility(kTRUE);
  liquid->SetFillColor(color_liquid);
  liquid->SetLineColor(color_liquid);
  liquid->SetLineWidth(1);
  PMrev->SetVisibility(kTRUE);
  PMrev->SetFillColor(color_pmrev);
  PMrev->SetLineColor(color_pmrev);
  PMrev->SetLineWidth(1);
  PMwin->SetVisibility(kTRUE);
  PMwin->SetFillColor(color_pmwin);
  PMwin->SetLineColor(color_pmwin);
  PMwin->SetLineWidth(1);
  PM->SetVisibility(kTRUE);
  PM->SetFillColor(color_pm);
  PM->SetLineColor(color_pm);
  PM->SetLineWidth(1);
  buf1->SetVisibility(kTRUE);
  buf1->SetFillColor(color_buf1);
  buf1->SetLineColor(color_buf1);
  buf1->SetLineWidth(1);
  buf2->SetVisibility(kTRUE);
  buf2->SetFillColor(color_buf1);
  buf2->SetLineColor(color_buf1);
  buf2->SetLineWidth(1);
  geom->SetTopVisible(0);
  geom->SetVisLevel(4);
  //
  // Generation of Photons
  //
  const Int_t nrun = 10;
  const Int_t nb_photon = 5000;
  const Double_t stepRindex = 0.1; //step for real part of index of wraptank
  Int_t krun;
  TLitSpontan *emission = new TLitSpontan("Scintillation","Light from liquid scintillator",
                                          "/TOP_1/TANK_1/LIQUID_1");
  for (krun=1;krun<=nrun;krun++) {
    emission->Gen(krun,nb_photon,tank_Rindex);
    tank_Rindex += stepRindex;
    wraptank->SetWrapIndex(tank_Rindex,tank_Iindex);
  }
  TLit::Get()->BookCanvas();
  gTwoPad->SetAllGrey();
  gTwoPad->CommentTL("Simulation of PSD in Nucifer");
  top->Draw("");
  gLitGp->SetTitle("real part of index of tank");
  gLitGp->Summary();
  gTwoPad->ChangePad();
  gLitGs->DoStat();
  TLit::Get()->CloseFiles();
  return 0;
}
